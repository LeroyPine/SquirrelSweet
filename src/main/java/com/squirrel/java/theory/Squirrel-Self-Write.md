## Squirrel  - Self - Write

### Java

- HashMap: 	 hashMap底层是数组+链表+红黑树

1. 计算key的hashCode,并将其无符号右移16位,对高低位进行一个异或运算,避免低位相同造成hash冲突。
2. 判断数组是否为空,如果为空进行第一次扩容也就是初始化,如果指定了集合容量,那么就取于该容量嘴接近的2的n次幂的整数,作为集合的容量
3. 根据hashCode与数组长度-n 进行位运算,的到数组的下标。
4. 再判断当前数组的下标该位置是否有节点,如果没有那么就插入一个节点。如果有节点,判断当前插入的key是否与该节点的key是否相同,如果相同则返回,判断当前节点属于链表节点还是树节点,如果是链表节点那么遍历这个链表,并插入到链表尾部,如果是树节点,按照红黑树的节点插入逻辑进行插入。如果链表节点个数大于到8,那么转换成红黑树。
5. 判断当前集合元素是否到达了集合的阈值,如果超过了那么就进行扩容操作。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

- ConcurrentHashMap:

1. 校验key和value的值不能为空
2. 计算key的hashCode, 判断数组为空,如果为空进行第一次扩容,扩容的时候通过cas保证只有一个线程进行扩容。通过一个集合大小的控制变量进行判断。
3. 通过hashCode与数组长度-1进行与运算计算出该节点在数组中的下标,并判断该下标处是否有节点,如果无节点,那么通过cas设置该新节点。
4. 如果不为空判断是否处于扩容阶段,并进行协同迁移。（协同迁移如何迁移？）
5. 否则使用synchronize锁定头结点。如果是链表就插入到链表尾部。如果是红黑树节点就按照红黑树的插入逻辑插入到红黑树中。如果链表长度到8的时候那么进行链表转红黑树的操作。
6. 对集合元素的大小进行+1操作.

- hashmap的长度总是设置为2的整数次幂的原因？
  1. 因为hashmap计算hashCode的时候,总是将hashCode的高16位与低16位进行异或运算得到hash值,这样可以保留高位的特征,避免某些key的低位相同,造成hash冲突。
  2. 同时数组下标的计算方式是: hashCode 与 n-1进行位运算,其实就是相当于 hashCode与n进行取余计算,这个公式只有在n为2的整数次幂时才正确。而位运算在计算机中运算更快。
- hashmap 扩容后是否需要进行 rehash？
  1. 1.8之后不需要进行rehash。下标的计算方式是通过hash值与数组长度取模进行计算,hashmap扩容都是变为之前的2倍,这样的话,当hash值与数组长度-1进行位运算的时候,只需要多看一位,看hash值与1的位运算结果。如果为1,那么该元素在新数组中的下标位置为  之前的index+之前的数组长度。如果为0,那么该元素在数组中的下标位置不变。
-   为什么链表长度为8的时候进行红黑树的转换？
  1. hashmap中节点分布遵循泊松分布,链表长度超过8的概率极低。
  2. 在链表长度较短的时候时间复杂度和红黑树没什么区别。
  3. 红黑树的空间占是链表的两倍。
- Hashmap 与ConcurrentHashMap的区别？
  - hashmap 线程不安全、key value 可以为null、
  - concurrent 线程安全、key value 不能为null、

