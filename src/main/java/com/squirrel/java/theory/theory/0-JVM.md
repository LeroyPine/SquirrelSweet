### JVM内存结构？

- 堆:对象主要存储的区域
- 方法区:存储类的元信息以及静态变量等
- 虚拟机栈:方法执行对应创建一个栈帧,方法的执行和结束对应着入栈和出栈的过程。
- 本地方法栈:与虚拟机栈类似。
- 程序计数器:指向当前线程的下一个执行命令的地址,因为线程的执行需要CPU的调度,CPU在某个时间段会把时间片分给别的线程,在分给这个线程的时候,该线程需要知道在哪里执行。

### 类的加载时机？

- new 对象的时候
- 访问类的静态变量的时候
- 访问类的静态方法的时候
- 反射
- 初始化一个类的子类的时候
- 虚拟机启动时候,定义了main()方法的那个类

### JVM类的加载机制？

- 首先将.java文件编译成.class文件
- 然后将其读进内存
- 然后进行Jvm验证、准备、解析、初始化等操作
- 准备的话就是为类变量分配内存空间以及默认值
- 解析的话就是将class文件中的符号引用转换成直接引用,指向类对象的地址和类方法的地址
- 然后就是进行类初始化。 初始化实例变量以及执行代码块等

### JVM类加载器以及双亲委派机制？

- BootStrapClassLoader :启动类加载器
- ExtensionClassLoader: 额外包类加载
- ApplicationClassLoader:应用程序类加载器
- CustomerClassLoader:用户自定义类加载器
- 双亲委派机制:加载类的时候,如果当前加载器有父类加载器,那么就找到最顶层的父级加载器进行加载,如果加载不到,在一层一层的向下进行加载。

### 什么打破了双亲委派机制？

- SPI机制: **SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。 这样可以在运行时，动态为接口替换实现类。**
  - JDBC:加载数据库驱动的时候,因为数据库的驱动都是由第三方厂商去进行编写的,Java本身是不提供的,所以直接让线程上下文加载器也就是应用程序加载器去进行加载。
- Tomcat类加载机制:部署不同的服务,依赖可能存在不同版本,各个web项目下的class文件优先由WebClassLoader进行加载,然后在用其父类进行加载.

### 常量池和运行时常量池？

- 常量池是.java文件编译为.class文件后,存储的符号引用
- 运行时常量池是jvm类加载完成后将符号引用值指向转存到运行时常量池,在解析阶段将符号引用替换为直接引用。(包含字符串常量池)

### New一个对象发生了什么？

- 首先判断当前类是否有进行了加载,如果未加载首先要进行当前类的加载
- 然后在堆中分配对象所需的内存(包含子类和父类的实例变量)
- 对所有的实例变量赋默认值
- 执行实例初始化代码块: {}->构造

### 如何确定一个对象是否可以被回收？

- 通过可达性分析算法,GCRoot,找出一条引用链,没有在引用链上的则可以进行回收
    - 虚拟机栈中引用的对象
    - 方法区中静态变量引用的对象
    - 方法区中常量引用的对象
- 引用计数法:持有一个引用的时候计数加1,没有引用的时候判断可以被回收

### 垃圾回收算法有哪些？

- 标记-复制:将存活的对象复制到另一个区域中,然后将死亡对象所在的区域进行清空
- 标记-清除:将要回收的对象标记出来,然后进行清除
- 标记-整理:将存活的对象整理到一边,然后把存活边界外的内存空间都清除一遍。

### CMS垃圾回收机制？

- 初始标记:根据可达性分析法GC-ROOT,标记出存活的对象,该过程是Stop The Word的,即用户线程是暂停的
- 并发标记:该过程是根据初始标记所标记的对象为起点,再去遍历引用链,如果某个对象没有和GC-ROOT的节点相联系时候,则被标记为垃圾
- 重新标记:Stop-the-word,由于刚刚是并发执行的,用户线程可能会把某些对象的引用进行了一个修改,所以需要重新标记一下GC-ROOT。
- 并发清理:之后就是进行回收垃圾

### G1垃圾回收机制？

https://xie.infoq.cn/article/a67ca0dae583d5ba0bd30bc53

- G1抛弃了之前的分代收集的方式,面向整个堆进行回收,把内存划分为多个大小相等独立的Region。
- G1最大的优势在于可预测的停顿时间模型,G1会收集每个Region的回收之后的空间大小,回收需要的时间,根据评估得到的价值,在后台维护一个优先级列表,
- 然后基于我们设置的停顿时间优先回收价值收益最大的Region

### JVM有哪些参数？

- 堆
  - -Xms:初始堆大小
  - -Xmx:最大堆大小
- -Xmn:年轻代大小---整个堆大小=年轻代大小 + 年老代大小 + 持久代大小. eden+ 2 survivor space
- -XX:PermSize:方法区大小
- -Xss:线程栈大小: 512K
- -XX:SurvivorRatio:Eden和Survivor比例
- -XX:+PrintGCDetails:打印GC详细信息
- -XX:+UseConcMarkSweepGC:使用CMS

### GC时间过长如何分析？    https://segmentfault.com/a/1190000023937207

- 当时有用户反馈查看评价问题的时候很慢,然后当时查了sql的索引这些,都没问题的sql执行还是很快的,当时就想是不是垃圾回收的问题。
- 然后我们这是有一个监控平台的,可以看每台机器的性能以及内存占用,GC等情况的。然后就看一了一下当时的GC情况,发现了当时系统majorGC的时间有点长,
- 然后就去看GC日志,发现 Remark重标记阶段时间比较长,因为重标记阶段,用户线程是暂停的,所以会导致用户反映系统慢.然后就开始着手降低remark时间。
- remark阶段主要是通过扫描堆来判断对象是否存活,但是remark需要扫描的是整个堆,因为可能存在跨代引用的情况,比如新生代持有老年代对象的应用。
  - jvm默认在remark阶段之前增加了一个**可中断的并发预清理**,这个预就是针对新生代的, 这个机制是判断新生代使用是否超过2M,如果超过那么就执行minorGC,
  - 否则等待有一个限制时间5s,如果5s没有发生 minorGC 仍然执行remark。
- 解决办法就是增加了一个参数 在CMS重新标记之前强行执行一次 minor GC。

### 调优:个人中心项目(GC日志)

**MajorGC和minor GC频繁**

- minorGC频繁的原因,可能是由于新生代空间比较小,Eden区很快就会被填满,就会导致频繁的minorGC,
- 可以通过增大新生代空间来降低minor GC的频率,例如 新生代中的Eden区增加一倍数,那么Minor GC的次数就会减少一半。
  - 扩大新生代 Eden 的空间,不会增大MinorGC的时间么？
    - MinorGC的时间实际上是由两部分组成的,一部分扫描对象,一部分是复制对象。明显复制对象的时间比较长, 所以说minor GC的时长更多取决于GC后存活对象的数量,而非Eden区的大小。
- **结论:**如果应用存在大量的短期对象,应该选择较大的年轻代,如果存在相对较多的持久对象,老年代应该适当增大。**


