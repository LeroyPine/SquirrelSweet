### 锁

https://github.com/NotFound9/interviewGuide

- ![img.png](img.png) 住你的❤

### 线程安全？

- jvm中的：程序计数器,线程栈,本地方法栈是线程独有的一块内存,不存在线程安全,而堆,方法区的内存是线程之间共享的区域,当多线程的情况下,存在线程安全的情况。
  在共享区域,不同线程对其进行操作,可能造成不同线程读取到这个变量的值不同,从而引发一系列问题。
    - 线程安全有很多解决方案：
        - JMM：通过 synchronized,volatile 等配合使用,
        - ThreadLocal 通过线程隔离的方式防止任务在共享资源上发生冲突,线程本地存储是一种自动化机制,可以为使用相同变量的不同线程创建不同的存储。
        - 最后就是加锁, java内置锁 或者并发包下的lock锁 以及现在的分布式锁等等

- 如何减少上下文切换？
    - 无锁编程：可以参照ConcurrentHashMap那样,分段处理,例如根据请求的数据ID将线程进行分配,A处理A段,B处理B段
    - CAS算法：利用Cas算法,其实是一种乐观锁的形式,有效较少一部分不必要的锁竞争带来的上下文切换。
    - 避免创建不需要的线程: 任务少的情况下,创建了很多线程,造成大量的线程处于等待状态。

- 死锁产生的四个必要条件：
    - 互斥条件 ： 一个资源每次只能被一个进程调用
    - 请求与保持条件：一个进程因请求资源而阻塞时,对已获得的资源保持不放
    - 不剥夺条件：进程已经获得的条件,不能强行剥夺
    - 循环等待条件：若干进程之间形成头尾相接的循环等待资源关系
- 为什么有了synchronize 还要 juc lock
    - synchronized 只能保证互斥条件以及请求与对获得资源不释放不发生死锁,并不能主动释放资源,
    - lock 锁支持中断,也支持尝试获取锁。

### Synchronized

- synchronized 首先英文就是同步的意思.可以让synchronized修饰的方法,代码块,每次只能有一个线程在执行,以此来实现数据的安全。一般可以用来 修饰 同步代码块,实例方法,静态方法,
  加锁对象分别为同步代码块内的对象、实例对象、类
- synchronized 实现原理：在编译时候,在同步块的进入和退出指令后,会分别生成对应的monitorenter和moniterexit指令进行对象,代表尝试获取锁和释放锁,
  为了保证异常的情况下也能释放锁,javac为同步代码块添加了一个隐式的try-finally 在finally中会调用monitorexit 命令释放锁

- 偏向锁,轻量级锁,重量级锁的执行流程是怎样的？
    - Java对象是由 对象头 + 实例数据 + 对其填充三部分组成,而对象头主要包含 MarkWord + 指向对象所属的类的指针组成（如果是数组对象,还会包含长度）
    - Mark Word：存储对象自身的运行时数据,例如hashCode,GC分代年龄,锁状态标志,线程持有的锁等等。所以主要通过设立是否有偏向锁的标志位和锁标志位用于区分 其他位数存储的数据是什么？
    - jdk 1.6的时候对锁进行了优化,引入了 偏向锁、轻量级锁、适应性自旋、锁消除、锁粗化
    - 锁的升级过程： 无锁、偏向锁、轻量级锁、重量级锁
    - 偏向锁： 锁不仅不存在竞争,而且总是由同一线程多次获得， 简单来说就是锁处于偏向锁状态时,会在mark word中存当前持有偏向锁的线程ID,如果获取锁的 线程ID与它一致,那么就直接执行。 -
      如果没有获得锁的线程进入同步块时候,发现是偏向锁并且此时线程ID不是自己的ID,那么就进行撤销偏向锁的操作。如果线程存活并且还在同步 快
      中执行,那么将锁升级为轻量级锁,原来的线程继续拥有锁,不过锁已经变成的轻量级锁,其他线程进行自旋,获取轻量级锁。 （偏向锁解锁：锁标记位恢复为无锁,或者轻量级锁）
    - 轻量级锁：JVM会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间,我们称为Lock record,如果一个线程获取到并且发现是轻量级锁, 会将锁的Mark Word复制到自己的Lock
      record,然后线程尝试用CAS操作将锁的 mark word 替换为自己lock record的指针,如果替换成功,证明获取轻量级
      锁成功,如果失败,表明有其他线程正在竞争锁,会使用自旋在获取锁，JDK采用了自适应性自旋,如果自旋失败,那么就把锁升级为重量级锁。 （轻量级解锁：将线程栈中的LockRecord用Cas替换到MarkWord中）
    - 重量级锁：在重量级锁中没有竞争到锁的对象会park被挂起,退出同步块时unpark唤醒后续线程,唤醒操作涉及到操作系统的调度会有额外的开销。
    - 当多个线程同时请求某个重量级锁时,重量级锁会设置几种状态来区分请求的线程：
        - Contention list：所有请求锁的线程将被首先放置到该竞争队列。
        - Entry list：Contention List中那些有资格成为候选人的线程被移到Entry List,主要是为了减少对Contention List的并发访问,因为既会添加新线程到队尾, 也会从队尾取线程。
        - Wait Set：那些调用wait方法被阻塞的线程被放置到WaitSet。
        - OnDeck: 任何时刻最多只有一个线程正在竞争所,该线程被称为OnDeck
        - Owner：获的锁的线程称为Owner,!Owner:释放锁的线
        - 步骤：
            - 线程在进入竞争队列的之前,程序会先尝试自旋使用CAS操作获取锁,如果获取不到就进入Contention List 队列的尾部。
            - 持有锁的线程在解锁的时候,如果Entry list,会先将Contention list中队列尾部的部分线程移动到Entrylist
            - 如果entry list不为空,从中取一个线程，r让他成为竞争锁的线程,此时需要与还在自旋获取重量级锁的线程竞争。
            - 竞争锁的线程获取到锁,则继续执行
            - 如果持有锁的线程,调用了wait方法,则释放锁,并进入wait Set队列,同时释放CPU资源,也同时释放锁
            - 线程调用锁对象的notify 方法,之前调用wait方法等待的这个线程才会从 wait Set中移动到Entry list，等待获取锁

### 为什么说轻量级，重量级锁是不公平的？

- 获取轻量级锁的过程时线程通过CAS要将MarkWord替换成自己的Lock Record的指针,比较随机,看谁能先替换掉。不公平
- 重量级也存在自旋获取锁,刚进入到重量级锁的线程不会直接进入contention list队列,而是自旋去获取锁,所以后进来的线程也有一定的几率 先获取到锁。

### AQS --

https://github.com/NotFound9/interviewGuide/blob/master/docs/Lock.md

- 抽象队列同步器,用于实现基于先进先出等待队列的锁和同步器的框架,实现锁ReentrantLock，CountDownLatch，Semaphore,ReentrantReadWriteLock 等。

- ReentrantLock 其实就是有一个变量Sync，Sync的父类是AbstractQueuedSynchronizer.
- ReentrantLock 的公平锁和非公平锁的区别？
    - 公平锁：首先判断state是否为0,如果为0并且等待队列为空,才会用CAS操作抢占锁,抢占成功就获的锁,没成功并且当前线程不是获得锁的线程,都会被 加入到等待队列。
    - 非公平锁：在CAS更新state失败后会调用 tryAcquire() 来判断是否需要进入同步队列,会再次判断state是否为0,为0就会去CAS更新state值,更新成功则获取锁, 否则就进入等待队列, 进等待队列之前会抢锁。

- Synchronized 和 ReentrantLock 锁的区别？
    - 都是可重入的,持有锁的线程再次申请锁时,会对锁的计数器+1.
    - 不同点：
        - Synchronized是一个Java关键字,是由JVM实现的,而ReentrantLock是JDK实现的,
        - 性能：在以前Sync锁的实现只有一种重量级锁的模式,性能比较差,后面引入了偏向锁和轻量级锁后就优化了很多,在线程不激烈的情况下,ReentrantLock和Sync 性能差不多,激烈的情况下
          ReentrantLock效率更加高一些。
        - 功能：synchronized只能修饰方法,代码块，reentrant 的加锁和解锁使用 lock 和 unlock方法，更加灵活,sync的等待队列只有一个,调用wait()方法会进入等待
          队列,而reentrant可以有多个条件等待队列,可以分组唤醒,sync提供了 notify 和 notifyALL 的方法唤醒线程,reent 提供了一种中断等待锁的机制,lock.lockInterrupt
          一旦线程被中断,就会停止等待。 reentrantlock 可以设置超时时间,而不是一直等待锁。
        - sync是非公平锁,reentrant 有两种模式

- ReentrantLock 的加锁流程？
    - 非公平锁加锁过程：
        - 尝试使用CAS操作将锁的状态由state由0改为1,修改成功则线程获得锁。
        - 不成功就会再次尝试去抢锁,以及判断这个线程是否是当前持有锁的线程,如果是只需要将state+1,代表锁重入
        - 抢锁不成功,也不是持有锁的线程,那么就会添加到等待队列然后调用LockSupport.park 进行阻塞等待,然后被唤醒。
    - 公平锁的加锁过程：
        - 如果当前锁没有被其他线程持有,并且等待队列中也没有其他线程等待,那么就是用CAS操作去抢锁。
        - 或者线程就是当前持有锁的线程,那么就对state+1,,代表锁重入
        - 以上都不是.就加入到等待队列进行等待


- 谈谈你对AQS的理解？
    - AQS是AbstractQueuedSynchronizer 的缩写,是一个抽象同步队列类,可以基于它实现一个锁,例如ReentrantLock,只是需要实现tryAcquire() 获取资源 ,和tryRelease
      释放资源的方法,AQS会根据tryAcquire 的返回结果 进行下一步的操作
    - 如果为true,代表线程获得锁了。
    - 如果为false,代表线程没有获取到锁,由AQS负责将线程添加到CLH等待队列中,并进行阻塞等待,当前一个线程释放锁时,QS对这个线程进行唤醒。

### 悲观锁和乐观锁是什么？

- 悲观锁：假定每次取数据的时候都会修改这个数据,所以在取数据的时候就会进行加锁,这样其他调用者就不能取数据,阻塞,一直到获取锁，Java中sync和 Reentrant就是悲观锁

#### 乐观锁和悲观锁的区别？

- 乐观锁适合多读的场景，这样只有读写冲突会发生的比较少,减少加锁的性能开销,只有真正修改数据的时候才加锁。java中的atomic原子变量类就是乐观锁的实现。
- 版本号机制：使用版本号来实现,对数据加上一个版本号,代表修改次数,修改后加1，修改数据是判断数据的版本号跟之前的是否一至，如果一致则修改，否则重试。
- CAS操作:在更新数据时会传入之前取得值,在内存判断当前内存中的值是否跟之前的一致，如果一致在进行更新。
- ABA问题,atomic原子类提供了一个atomicStamped 类，增加了一个版本号,修改的时候比较之前取得值和版本号,如果都相同。那么进行更新,否则不更新
- CAS操作的缺点？
  -  循环时间长开销打： 自旋CAS操作如果不成功就一直循环执行到成功,如果长时间不成功,会给CPU带来非常大的开销。
  -  CAS只对单个共享变量有效： 多个变量防砸第一个对象里来进行CAS 操作。
   
