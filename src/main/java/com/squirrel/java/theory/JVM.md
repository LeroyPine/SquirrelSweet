### https://blog.csdn.net/a646705816/article/details/109538744 干货

### 内存结构

- 程序计数器
    - PC 寄存器用来存储指向下一条指令的地址，即将要执行的指令代码。由执行引擎读取下一条指令。
    - 为什么要使用寄存器? -因为CPU会不停的切换每个线程,单个线程不总是执行的,需要CPU的调度,所以当CPU重新找到这个线程的时候,需要知道 他下一步要做什么,所以需要存储指向下一条指令的地址。
- 虚拟机栈
    - 每个线程在创建的时候都会创建一个虚拟机栈,内部保存这一个个栈帧,对应着一次次的Java方法的调用,同时也是线程私有的。生命周期和线程一致。
    - 主管java程序的运行,保存方法的局部变量,部分结果,并参与方法的调用和返回。
        - 栈帧的内部结构：
            - 局部变量：存储方法参数以及方法体内的局部变量
            - 操作数栈：主要用于保存计算过程中的中间结果,同时作为计算过程中变量临时的存储空间
            - 动态链接：指向运行时常量池的方法引用,将类中的符号引用转换为调用方法的直接引用
            - 返回地址：PC计数器的值作为返回地址,即调用该方法的指令地下一条指令的地址。
- 本地方法栈
    - 本地方法栈管理本地方法的调用,同样也是私有的,使用C语言实现。
- 堆
    - 栈是运行时的单位,而堆则是存储的单位,栈解决的是程序如何执行,堆解决的是数据存储在何处。
    - java堆用来存放对象实例,几乎所有的对象都在这里分配内存
    - 分代的唯一理由就是用来 优化GC
- 方法区:
    - 概述：存放着类的元信息和运行时常量池
    - 运行时常量池 ： 将类常量池中的符号引用转换为直接引用, 字符串常量池可以理解为运行时常量池分出来的部分,class常量池中的字符串会被装载到字符常量池中。
    - 用于存储已被虚拟机加载的常量、静态变量、即时编译器后的代码缓存。
    - 类的元信息保存在本地内存的元空间,字符串常量池以及静态变量存在堆中
    - 移除永久代的原因？ - 为永久代设置空间大小是很难确定的,类是可以动态加载的,永久代存在于JVM中,可能会造成OOM。 - 对永久代调优比较困难

### 内存模型 JMM

- 概述：Java内存模型,其实是一种规范,主要是用来保证主内存与每个线程本地内存的交互,保证内存可见性。目的就是解决多线程的环境下,存在的原子性，可见性,有序性问题。
- 原子性：一个操作不能被打断,要么执行要么不执行,在并发访问时是线程非安全的,要想保证原子性就得对访问该数据的地方进行同步操作。
- 可见性: 线程本地内存和主存可能存在不一致的情况,就会导致可能不同线程看到的数据不一致的情况,需要通过volatile、synchronize、lock 等进行解决
- 有序性：由于编译器和处理器可能会对操作进行重排序，编译器和处理器在重排序时,不会影响单线程的执行结果,但是在多线程的情况下可能会改变程序的执行结果。
- JMM 通过 volatile、synchronize、以及定义的happen-before原则来对这些情况进行处理，使得编程时可以解决这些并发问题。

### 类加载

- 类的生命周期：加载、验证、准备、解析、初始化。 加载验证准备初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始。
- 类的加载:查找并加载类的二进制数据
    - 通过类的全限定名获取其定义的二进制字节流-
    - 将这个字节流锁代表的静态存储结构转化为方取得运行时数据结构
    - 在堆中生成一个代表这个类的Class对象,作为对方法区中这些数据的访问入口
- 验证: 确保被加载的类的正确性
    - 是否符合class 文件规范,符号引用验证.元数据验证
- 准备：
    - 对静态变量进行分配内存,初始化赋值,不过此时赋的值都是默认值
- 解析
    - 把类中的符号引用转换为直接引用

- 类加载器：JVM类加载机制
    - BootStrapClassLoader
    - ExtClassLoader
    - AppClassLoader
        - UserClassLoader
        - UserClassLoader
    - 全盘负责：当一个类加载器负责某个类的加载的时候,那么该Class所依赖的Class也由该类的加载器进行载入,除非显示的使用另外一个类加载器来进行载入
    - 父类委托：先让父类加载器试图加载该类,只有在父类无法加载的时候才尝试从自己的类路径中加载该类。
    - 缓存机制: 缓存机制保证所有加载过的Class都会被缓存,当程序中需要使用某个Class时,类加载器先从缓存区寻找该Class,缓存不存在时，系统才会读取该类对应的二进制 数据，并将其转换成Class对象.存入缓存区。
    - 双亲委派机制：一个类加载器收到了类加载的请求，首先不会自己去尝试加载这个类，而是吧请求委托给父加载器去完成，依次向上,所有的类加载请求最终都应该
      被传递到顶层的启动类加载器中，只有当父加载器在他的搜索范围中没有找到所需的类,既无法完成该加载，子加载器才会尝试加载该类。

  为何要打破双亲委派？
    - JDBC spi 因为类加载器受到加载范围的限制,在某些情况下父类加载器无法加载到需要的文件,这时候就需要委托子类加载器去加载class文件。
    - Tomact 需要保证各个web项目的类独立加载,不同项目的jar版本可能不同，需要保持依赖jar的相互独立。

### 垃圾回收

    - 

### 调试和排错

### new一个对象的过程？

- 首先校验当前类是否加载,如果没有加载,执行类加载机制
- 加载：从字节码加载成二级制流的过程.
- 验证：当加载完成后，校验Class文件是否符合虚拟机规范.
- 准备：为静态变量、常量赋默认值
- 解析: 把常量池中符号引用（以符号描述引用的目标）替换为直接引用（指向目标的指针或者句柄）的过程
- 初始化:执行static代码快,如果存在父类 先对其父类进行初始化
- 加载完成后：对象分配内存空间和初始化的过程，
- 为实例变量赋默认值
- 设置对象的头信息、对象hash码、GC分代年龄、元数据信息等

### 说说有哪些垃圾回收算法？

- 标记-清除
    - 统一标记出需要回收的对象,标记完成之后统一回收所有被标记的对象,由于标记的过程需要遍历所有的GC ROOT,清除过程也要遍历堆中所有的对象,所以 标记-清除算法的效率低下,同时也带来了内存碎片的问题。
- 复制算法
    - 为了解决性能的问题,复制算法应运而生,他将内存分为大小相等的两个区域，每次使用其中的一块,当一块内存使用完之后,将还存活的对象拷贝到另外一块内存 区域中,然后把当前内存清空.这样性能和内存的碎片得以解决，但是使用空间少了一半。
- 标记整理
    - 年轻代+老年代的内存结构,Eden + SO + S1 组成,98%的对象都是朝生夕死，实际存活的对象并不是很多,完全不需要用到一半的内存,所以默认比例是8:1:1
      在使用的时候使用Eden区和SOS1中的一个,每次都把存活的对象拷贝另外一个未使用的幸存区。同事清空Eden和使用的Survivor 这样下来内存的浪费只有10%了
    - 老年代的对象存活率比较高,不适合进行频繁的复制，而且也没有另外的空间兜底，标记整理：标记出所有存活的对象，让所有存活的对象都向一端移动，然后清理掉 边界以外的内存空间

### 什么是GCROOT ？ 有哪些 GCROOT?

- Java通过可达性分析算法来打到标记存活对象的目的,定义了一系列的GC ROOT作为起点,从起点开始向下搜索,搜索走过的路径成为引用链,当一个对象到GC ROOT没有引用 任何引用链相连的话,则对象可以判定是可以回收的。
- 而可以作为GC ROOT的对象包括： 栈中引用的对象、静态变量、常量引用的对象、本地方法栈native方法引用的对象

### 垃圾回收器了解么？年轻代和老年代有哪些垃圾回收器？

- 年轻代： Serial,Parallel 复制算法
- 老年代:  CMS 获取最短停顿时间为目标的收集器,相对于其他的收集器STW的时间更短暂,可以并行收集,同时他基于标记-清除算法,整个GC过程：
    - 初始标记：标记GC-ROOT能够关联到的对象,需要STW 停止用户线程
    - 并发标记：从GC-ROOT直接关联对象开始遍历整个对象图的过程,不需要STW
    - 重新标记：为了修正并发标记期间,因用户程序继续运作而导致标记产生改变的标记,需要STW
    - 并发清除：清除删除标记阶段的已经死亡的对象,不需要STW
    - 并发标记和并发清除的时间最长,但是不需要停止用户线程,而初始标记和重新标记的耗时较短,但是需要停止用户线程,整个过程造成的停顿时间较短,大部分时候是 可以和用户线程一起工作的。

### G1了解么？

- G1是JDK9默认的垃圾收集器,而且不在区分年轻代和老年代了。
- 把内存划分多个区域,每个区域的大小可以通过-xx G1HeapRegionSize,超过Region大小一半的被认为是大对象,超过整个Region大小的被认为是超级大对象,将会被存储在
  连续N个区域中,G1在进行回收的时候会在后台维护一个优先级列表,每次根据用户设定允许的收集停顿时间优先回收收益最大的区域。
- G1回收步骤：
    - 初始标记：标记GC-ROOT能关联到的对象,需要STW
    - 并发标记：从GC-ROOT的直接关联的对象开始遍历整个对象图的过程,扫描完成后还会重新处理并发标记中产生变动的对象
    - 最终标记: 短暂 暂停用户线程,在处理一次.需要STW
    - 筛选回收: 更新Region的统计数据,对每个Region的回收价值和成本进行排序。需要STW
- G1特点：
    - 空间整合:基于 标记-整理算法实现的收集器,从局部上看是基于赋值算法实现的,意味着运行期间不会产生内存空间碎片。
    - 可预测的停顿: 能让使用者明确指定在一个长度为M毫秒的时间片段内,消耗在GC上的时间不超过N毫秒

### 什么时候会触发YGC和FGC?对象什么时候会进入老年代？

- 新对象在分配空间时,年轻代容量不够,则需要进行YGC,如果ygc后还是放不下,那就将这个对象放入老年代,老年代如果也没法分配空间,那么触发FGC,FGC之后如果 还放不下,则报OOM异常。

### 如何判断一个对象是否死亡？
- 

### 频繁FGC怎么排查

- 内存分配不合理,比如Eden区太小,导致对象频繁进入老年代,这时候通过启动参数配置就能看出来。另外就是内存泄漏。
- 查看GC log 查看内存回收情况,在dump下当时的内存文件,解析后查找到具体的问题代码。

### JVM 调优实战

- 评价导出OOM: 一般每周五下午时候,业务集中导评价数据,大家同时导出,而且有的业务人员导出的数据量比较大,程序在前端加了重复点击的功能,后台没有加 可能有的业务嫌慢刷了页面又重新点击,导致的情况就是OOM,
  因为当时JVM开启了内存溢出会dump快照：
  `java -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/app/logs/heapdump.hprof`
  ,然后在我们运维平台把快照下载下来,用jProfile进行分析,发现导出时组成的评价记录的大对象很多,其实就定位出了是由于导出导致的OOM,后来就想了几个方案
  ,先是在业务上对导出操作进行限制,其次限制单次导出的数量。加分布式锁。提示排队导出。 加了之后就没出现过OOM了。
  但是还会存在一个问题,对比同样查询条件的一个请求的效率和多个请求的效率对比,发现多个请求的导出的时候比单个导出的明显慢了一些，就通过pingPoint查看
  机器的GC情况,发现多个请求的时候YGC发生的次数挺多的,其实对业务也没多大的损伤,就是慢请求增加,其实这时候在减少点同时导出的用户个数也能解决这个问题, 但是为了用户体验和吞吐量 就加了2G的堆内存。然后把年轻代调的大一点。减少
  YGC的频率

### 202121  Self Content：

- Java内存区域的划分: java程序计数器,虚拟机栈,本地方法栈, 方法区和堆. 前面三个是线程独享的区域,后面两个是线程共享的区域。
- 程序计数器：就是是存储线程的执行的下一条指令的地址,因为系统会存在线程切换的情况,当线程挂起之后,重新执行的话需要知道下一条指令所在的地址
- 虚拟机栈:执行一个java方法时,会创建一个栈帧,来存储局部变量表,操作数栈。方法调用完毕后会对栈帧从虚拟机中移除。局部变量表存储了java基本类型,对象
  引用（可以是对象的存储地址,也可以是代表对象的句柄）和returnAdress类型
- 本地方法栈:jvm提供的一些本地方法,和虚拟机栈类似
- 方法区:存储类变量信息,运行时常量池（字符串常量池 类常量池）
- 堆:存储了几乎所有对象和数组,是被所有线程进行共享的区域。在逻辑上是连续的,在物理上可以是不连续的内存空间。

## 创建对象的过程？

- 类加载检查:是否已经创建过该对象
- 分配内存：给对象分配内存（类加载时候一个对象的大小就确定了）,分配方式：指针碰撞和空闲列表
- 对象初始化。（将对象的一些信息设置在对象头中） （构造一个实例对象）

## Java对象内存布局？

- 对象头：包含对象自身运行时数据(Mark word),类型指针(Class point,指向对象所属的类),如果对象是数组,还需要包含数组的长度。 mark word:存储 hashCode,GC年龄，线程ID,锁标志等。
  classpoint:指向对象内存地址的指针。
- 对象中实际数据:保存对象的非静态成员变量数据。实例数据存储的是真正的有效数据,即各个字段的值。
- 对齐填充：8字节的整数倍。

### 垃圾回收机制,对象在内存中的状态有几种？
- 可达状态：
- 可恢复状态：
- 不可达状态:

### 自定义加载器：
- 继承类加载器实现findClass方法。

### 类的加载过程?
- 装载:查找并装载类型的二进制数据
- 链接:执行验证、准备、解析 ：验证:确保被导入类型的准确性,准备:为类变量分配内存,赋默认值,解析:把类型中的符号引用转换为直接引用
- 初始化:把类变量初始化为正确的值