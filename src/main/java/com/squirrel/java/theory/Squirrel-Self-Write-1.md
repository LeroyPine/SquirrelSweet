## Squirrel  - Self - Write

#### Jvm

- Java内存结构有哪些？
  - 堆: 对象主要存在的位置。
  - 虚拟机栈: 每个方法的执行会在虚拟机栈创建一个栈桢,并对应着入栈以及出栈的过程。
  - 本地方法栈: 与虚拟机栈类似,不过是jdk提供的本地方法,由C++实现
  - 方法区: 存储类的元信息,静态变量,运行时常量池等
  - 程序计数器: 记录每个线程的下一个指令的地址。CPU在进行时间片切换的时候,线程会交替执行,当一个线程暂停后要继续执行的时候需要知道下一步指令的地址。
- 类的加载机制？
  - 按需加载,第一次使用该类的时候进行加载。
  - 装载,链接,解析,初始化。
  - 采用的是双亲委托加载机制。JDK 提供的几个类加载器,顶级加载器  BootStrapClassLoader,ExtensionClassLoader,AppClassLoader, 当加载一个类的时候,通过当前的类加载器逐层向上找到父类加载器,首先由父类加载器进行加载,如果加载不成功,那么由父类加载器在逐层向下找到加载器进行加载,这样就可以保证一个类只能被加载一次。
- 什么打破了双亲委派机制？
  - SPI机制.JDBC的类的实现是由不同的厂商来开发的,JDK默认的父类加载器加载不到,所以直接使用应用程序加载器直接进行加载。
  - Tomcat的类加载机制: Tomcat是一个web容器,可以包含不同的web项目,不同web项目依赖的相同限定类名的版本不同,如果用JDK默认的类加载器,相同限定类名类只能加载一个,web项目中的依赖的版本不同所以是不可行的。
- new一个对象发生了什么？ https://www.cnblogs.com/JackPn/p/9386182.html
  - 判断类是否已经被加载,如果没有没加载首先进行加载
  - 在堆中分配内存空间
  - 对所有实例变量赋默认值
  - 执行实例初始化代码,然后执行构造方法
- 如何确定一个对象是否可以被回收？
  - 引用计数法:如果该对象有一个引用进行+1计数,循环引用可以解决 ,但是多线程环境下要进行同步操作,性能比较低。
  - 可达性分析法:GCROOT(栈中的引用变量,方法区的静态变量等),查找引用这些变量的对象。
- 垃圾收集算法有哪些？
  - 标记-清除:
  - 标记-整理:
  - 复制算法: 分代收集中的年轻代。
- CMS垃圾回收机制？
  - https://tech.meituan.com/2020/11/12/java-9-cms-gc.html
  - https://www.jianshu.com/p/2a1b2f17d3e4
  - 初始标记:Stop The World。 标记出GCRoot出关联的对象（这些对象是不可进行回收的）
  - 并发标记:GC线程和用户线程同时执行。针对初始标记的对象在根据这些对象引用的对象的一个标记
  - 重新标记:Remark,Stop the world。重新标记,避免并发标记的时候修改了对象之间的引用关系。
  - 并发清理: 针对不可达的对象进行一个垃圾回收。
- 调优:  个人中心项目(GC日志)

#### Java

- HashMap: 	 hashMap底层是数组+链表+红黑树

1. 计算key的hashCode,并将其无符号右移16位,对高低位进行一个异或运算,避免低位相同造成hash冲突。
2. 判断数组是否为空,如果为空进行第一次扩容也就是初始化,如果指定了集合容量,那么就取于该容量嘴接近的2的n次幂的整数,作为集合的容量
3. 根据hashCode与数组长度-n 进行位运算,的到数组的下标。
4. 再判断当前数组的下标该位置是否有节点,如果没有那么就插入一个节点。如果有节点,判断当前插入的key是否与该节点的key是否相同,如果相同则返回,判断当前节点属于链表节点还是树节点,如果是链表节点那么遍历这个链表,并插入到链表尾部,如果是树节点,按照红黑树的节点插入逻辑进行插入。如果链表节点个数大于到8,那么转换成红黑树。
5. 判断当前集合元素是否到达了集合的阈值,如果超过了那么就进行扩容操作。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

- ConcurrentHashMap:

1. 校验key和value的值不能为空
2. 计算key的hashCode, 判断数组为空,如果为空进行第一次扩容,扩容的时候通过cas保证只有一个线程进行扩容。通过一个集合大小的控制变量进行判断。
3. 通过hashCode与数组长度-1进行与运算计算出该节点在数组中的下标,并判断该下标处是否有节点,如果无节点,那么通过cas设置该新节点。
4. 如果不为空判断是否处于扩容阶段,并进行协同迁移。（协同迁移如何迁移？）
5. 否则使用synchronize锁定头结点。如果是链表就插入到链表尾部。如果是红黑树节点就按照红黑树的插入逻辑插入到红黑树中。如果链表长度到8的时候那么进行链表转红黑树的操作。
6. 对集合元素的大小进行+1操作.

- hashmap的长度总是设置为2的整数次幂的原因？
  1. 因为hashmap计算hashCode的时候,总是将hashCode的高16位与低16位进行异或运算得到hash值,这样可以保留高位的特征,避免某些key的低位相同,造成hash冲突。
  2. 同时数组下标的计算方式是: hashCode 与 n-1进行位运算,其实就是相当于 hashCode与n进行取余计算,这个公式只有在n为2的整数次幂时才正确。而位运算在计算机中运算更快。
- hashmap 扩容后是否需要进行 rehash？
  1. 1.8之后不需要进行rehash。下标的计算方式是通过hash值与数组长度取模进行计算,hashmap扩容都是变为之前的2倍,这样的话,当hash值与数组长度-1进行位运算的时候,只需要多看一位,看hash值与1的位运算结果。如果为1,那么该元素在新数组中的下标位置为  之前的index+之前的数组长度。如果为0,那么该元素在数组中的下标位置不变。
-   为什么链表长度为8的时候进行红黑树的转换？
  1. hashmap中节点分布遵循泊松分布,链表长度超过8的概率极低。
  2. 在链表长度较短的时候时间复杂度和红黑树没什么区别。
  3. 红黑树的空间占是链表的两倍。
- Hashmap 与ConcurrentHashMap的区别？
  - hashmap 线程不安全、key value 可以为null、
  - concurrent 线程安全、key value 不能为null、

#### Lock

- CAS
  - CAS涉及三个操作数:
    - 读写内存的地址
    - 该内存的地址的原值
    - 想替换的新值
  - 当传入的期望值与该内存的地址的值相同时,原子的将该地址的值替换成新值。
- CAS 的缺点
  - ABA问题,一个线程对该内存地址的进行修改,此时有另一个线程对其进行了修改,并改回来了原先的值,此时这个线程还是能对该内存地址成功的进行修改,而不知道有其他线程已经对该内存地址进行了操作。
  - 自旋操作,长时间不成的话会消耗CPU。
  - 只能对一个共享变量进行操作。

- Synchronzied
  - Synchronized是Java提供的一个关键字,既是一个同步锁。1.6之前其是一个重量级锁，使用时会直接使用操作系统底层的互斥锁,比较耗费性能。jdk1.6之后对其进行一系列的优化,synchronized具有了偏向锁,轻量级锁,重量级锁这几种形态。每个对象的对象头中包含了一个MarkWord,包含了对象的GC年龄,hashCode,线程ID,偏向锁标识,锁标记等。
  - 偏向锁:某个线程去获取锁时候,将自己的线程ID通过Cas设置到锁对象中,如果设置成功,代表获取到偏向锁,如果下次该线程再次获取这把锁的时候,比较锁对象中的线程ID是否和该线程的线程ID相同,如果相同那么直接拿到这把锁,否则进行锁的升级。
  - 轻量级锁: 某个线程获取锁的时候会将锁对象的markword 复制到自身的lockRecord上,然后在通过cas将锁对象的markword替换成自身的锁记录,如果替换成功.那么证明获取到轻量级锁,否则会进行一个适应性自旋来获取锁,如果一段时间后仍然获取不到,那么就升级为重量级锁。
  - 重量级锁:(调用操作系统底层的互斥锁进行同步操作)每个对象都有一个monitor监视器对象,并且存在几个队列。 
    - 竞争队列: 如果存在多个竞争锁线程,其是先进后出的一个队列。
    - 候选队列:  获取到锁的线程会从竞争队列尾部选取一个线程进入候选队列,并指定某一个线程去竞争锁,与未入队进行自旋获取锁的线程互相竞争。
    - 等待队列: 调用对象的wait方法会进入等待队里。
    - 竞争锁线程: OnDeck
- ReentrantLock
  - 是JDK提供的一个锁工具类,基于AQS实现的。
  - 加锁流程？
    - Aqs中有一个state变量,标识锁的状态,ReentrantLock在加锁时候,通过cas将state变量从0变为1,如果cas操作成功,并设置当前线程ID,证明获取锁成功。
    - 如果cas失败,在进行一次获取锁,并判断是否是锁重入,如果是当前锁冲入那么将state加1,获取锁成功
    - 如果再次获取锁失败,那么加入到等待队列,进行阻塞等待。Lock.Support.
- Synchronzied 和 ReentrantLock区别？
  - Synchronized 是非公平锁,ReentrantLock支持公平锁以及非公平锁。
  - Synchronized是jdk提供的一个关键字,RenntrantLock是java并发包下提供的类。
  - Synchronized在线程竞争激烈的情况下没有ReentrantLock高。
  - Synchronized 一直堵塞到获取到锁,ReentrantLock可以设置一个超时时间进行尝试获取锁。
  - ReentrantLock可以进行响应中断,synchronized不行。

- 谈谈你对AQS的理解？
  - AQS其实就是JDK提供的一个抽象队列同步器,可用于实现基于先进先出的等待队列的锁和同步器的框架,比如ReentrantLock、FutureTask、CountDownLatch等都是基于其实现的,该抽象类实现了线程的入队,出队等操作,所以我们只需要实现获取锁的逻辑,以及释放锁的逻辑即可。

#### Redis

- Redis有哪些结构？
  - string: 动态字符串, 预分配空间,维护了一个字节数组,分配了一定的空间,减少内存的频繁分配.字符串长度小于1M时,扩容是翻倍的现有空间,大于1M,扩容是扩展1MB的空间。
  - hash: 类似于java中的hashmap,基于数组+链表的结构。
  - list: 列表类似于java中 LinkedList,注意其是链表而不是数组。意味着ist的插入和删除操作非常快。
  - set: set集合,类似于java中的hashset,内部实现也是一个字典,每一个value是一个null
  - zset: 有序列表,  跳表。 类似于SortSet和HashMap的结合体。一方面它是一个set,保证了内部value的唯一性,另一方面value设置一个分值,用来进行排序。  单链表的某些节点的上层增加一些索引节点。
- Redis过期key是如何清理的？
  - 惰性清理:在访问key的时候,发现其已经过期,那么将其删除
  - 定时清理: 每次遍历所有的DB,从DB的过期字典里随机筛选出20个key,如果超过25%的key已经过期,那么继续对这个db进行清理,否则对下一个DB进行清理。
  - 内存不够时候进行清理:
    - 直接报错
    - 从所有结果集中进行淘汰:
      - 随机淘汰算法
      - LFU算法,使用频率最低的key。
      - LRU算法,最近最久未使用的key进行清理。
    - 从淘汰列表中进行淘汰:
      - ~~
- Zset是怎么执行查询操作的？
  - Zset是基于跳跃表+字典实现的.
    - 如果只是单key查询,那么就直接从字典中进行查询.
    - 跳跃表查询,首先根据要查找节点的分数与顶层的节点的分数进行比较,不断索引查找索引节点的区间,一层一层的向下查找,直到找到与这个节点相同的节点
- 跳跃表与平衡树,哈希表的比较？
- 为什么Mysql不是用跳跃表作为索引？
- 为什么平衡二叉树也不适合作为索引？

