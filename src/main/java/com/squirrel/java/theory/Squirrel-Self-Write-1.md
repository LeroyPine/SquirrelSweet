## Squirrel  - Self - Write

#### Evaluate

#### Jvm

- **Java内存结构有哪些？**
  - 堆: 对象主要存在的位置。
  - 虚拟机栈: 每个方法的执行会在虚拟机栈创建一个栈桢,并对应着入栈以及出栈的过程。
  - 本地方法栈: 与虚拟机栈类似,不过是jdk提供的本地方法,由C++实现
  - 方法区: 存储类的元信息,静态变量,运行时常量池等
  - 程序计数器: 记录每个线程的下一个指令的地址。CPU在进行时间片切换的时候,线程会交替执行,当一个线程暂停后要继续执行的时候需要知道下一步指令的地址。
- **类的加载机制？**
  - 按需加载,第一次使用该类的时候进行加载。
  - 装载,链接,解析,初始化。
  - 采用的是双亲委托加载机制。JDK 提供的几个类加载器,顶级加载器  BootStrapClassLoader,ExtensionClassLoader,AppClassLoader, 当加载一个类的时候,通过当前的类加载器逐层向上找到父类加载器,首先由父类加载器进行加载,如果加载不成功,那么由父类加载器在逐层向下找到加载器进行加载,这样就可以保证一个类只能被加载一次。
- **什么打破了双亲委派机制？**
  - SPI机制.JDBC的类的实现是由不同的厂商来开发的,JDK默认的父类加载器加载不到,所以直接使用应用程序加载器直接进行加载。
  - Tomcat的类加载机制: Tomcat是一个web容器,可以包含不同的web项目,不同web项目依赖的相同限定类名的版本不同,如果用JDK默认的类加载器,相同限定类名类只能加载一个,web项目中的依赖的版本不同所以是不可行的。
- **new一个对象发生了什么？** https://www.cnblogs.com/JackPn/p/9386182.html
  - 判断类是否已经被加载,如果没有没加载首先进行加载
  - 在堆中分配内存空间
  - 对所有实例变量赋默认值
  - 执行实例初始化代码,然后执行构造方法
- **如何确定一个对象是否可以被回收**？
  - 引用计数法:如果该对象有一个引用进行+1计数,循环引用可以解决 ,但是多线程环境下要进行同步操作,性能比较低。
  - 可达性分析法:GCROOT(栈中的引用变量,方法区的静态变量等),查找引用这些变量的对象。
- **垃圾收集算法有哪些**？
  - 标记-清除:
  - 标记-整理:
  - 复制算法: 分代收集中的年轻代。
- **CMS垃圾回收机制**？
  - https://tech.meituan.com/2020/11/12/java-9-cms-gc.html
  - https://www.jianshu.com/p/2a1b2f17d3e4
  - 初始标记:Stop The World。 标记出GCRoot出关联的对象（这些对象是不可进行回收的）
  - 并发标记:GC线程和用户线程同时执行。针对初始标记的对象在根据这些对象引用的对象的一个标记
  - 重新标记:Remark,Stop the world。重新标记,避免并发标记的时候修改了对象之间的引用关系。
  - 并发清理: 针对不可达的对象进行一个垃圾回收。
- 调优:  个人中心项目(GC日志)

#### Java

- **HashMap**: 	 **hashMap底层是数组+链表+红黑树**

1. 计算key的hashCode,并将其无符号右移16位,对高低位进行一个异或运算,避免低位相同造成hash冲突。
2. 判断数组是否为空,如果为空进行第一次扩容也就是初始化,如果指定了集合容量,那么就取于该容量嘴接近的2的n次幂的整数,作为集合的容量
3. 根据hashCode与数组长度-n 进行位运算,的到数组的下标。
4. 再判断当前数组的下标该位置是否有节点,如果没有那么就插入一个节点。如果有节点,判断当前插入的key是否与该节点的key是否相同,如果相同则返回,判断当前节点属于链表节点还是树节点,如果是链表节点那么遍历这个链表,并插入到链表尾部,如果是树节点,按照红黑树的节点插入逻辑进行插入。如果链表节点个数大于到8,那么转换成红黑树。
5. 判断当前集合元素是否到达了集合的阈值,如果超过了那么就进行扩容操作。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       

- **ConcurrentHashMap**:

1. 校验key和value的值不能为空
2. 计算key的hashCode, 判断数组为空,如果为空进行第一次扩容,扩容的时候通过cas保证只有一个线程进行扩容。通过一个集合大小的控制变量进行判断。
3. 通过hashCode与数组长度-1进行与运算计算出该节点在数组中的下标,并判断该下标处是否有节点,如果无节点,那么通过cas设置该新节点。
4. 如果不为空判断是否处于扩容阶段,并进行协同迁移。（协同迁移如何迁移？）
5. 否则使用synchronize锁定头结点。如果是链表就插入到链表尾部。如果是红黑树节点就按照红黑树的插入逻辑插入到红黑树中。如果链表长度到8的时候那么进行链表转红黑树的操作。
6. 对集合元素的大小进行+1操作.

- **hashmap的长度总是设置为2的整数次幂的原因？**
  1. 因为hashmap计算hashCode的时候,总是将hashCode的高16位与低16位进行异或运算得到hash值,这样可以保留高位的特征,避免某些key的低位相同,造成hash冲突。
  2. 同时数组下标的计算方式是: hashCode 与 n-1进行位运算,其实就是相当于 hashCode与n进行取余计算,这个公式只有在n为2的整数次幂时才正确。而位运算在计算机中运算更快。
- **hashmap 扩容后是否需要进行 rehash？**
  1. 1.8之后不需要进行rehash。下标的计算方式是通过hash值与数组长度取模进行计算,hashmap扩容都是变为之前的2倍,这样的话,当hash值与数组长度-1进行位运算的时候,只需要多看一位,看hash值与1的位运算结果。如果为1,那么该元素在新数组中的下标位置为  之前的index+之前的数组长度。如果为0,那么该元素在数组中的下标位置不变。
-   **为什么链表长度为8的时候进行红黑树的转换？**
  1. hashmap中节点分布遵循泊松分布,链表长度超过8的概率极低。
  2. 在链表长度较短的时候时间复杂度和红黑树没什么区别。
  3. 红黑树的空间占是链表的两倍。
- **Hashmap 与ConcurrentHashMap的区别**？
  - hashmap 线程不安全、key value 可以为null、
  - concurrent 线程安全、key value 不能为null、
- **LinkedHashMap？**
  - 底层也是HashMap 不过每个节点有两个指针,指向前一个节点和后一个节点,形成一个双向链表。
  - accessOrder 实现了按照插入顺序以及访问顺序。 实现了LRU。
- **ArrayList和LinkedList**
  - ArrayList 底层是一个Object数组。默认数组长度为0,添加第一个元素的时候会初始化一个数组长度为10的数组,后面如果元素超过数组长度,那么进行扩容,新数组的容量为原来的1.5倍。
  - LinkedList底层使用的是双向链表,每个节点保存了指向前驱节点和后继节点的指针,初始化时,不执行任何操作,添加第一个元素时,再去构造链表中的节点。

#### Lock

- **CAS**
  - CAS涉及三个操作数:
    - 读写内存的地址
    - 该内存的地址的原值
    - 想替换的新值
  - 当传入的期望值与该内存的地址的值相同时,原子的将该地址的值替换成新值。
- **CAS** **的缺点**
  - ABA问题,一个线程对该内存地址的进行修改,此时有另一个线程对其进行了修改,并改回来了原先的值,此时这个线程还是能对该内存地址成功的进行修改,而不知道有其他线程已经对该内存地址进行了操作。
  - 自旋操作,长时间不成的话会消耗CPU。
  - 只能对一个共享变量进行操作。

- **Synchronzied**
  - Synchronized是Java提供的一个关键字,既是一个同步锁。1.6之前其是一个重量级锁，使用时会直接使用操作系统底层的互斥锁,比较耗费性能。jdk1.6之后对其进行一系列的优化,synchronized具有了偏向锁,轻量级锁,重量级锁这几种形态。每个对象的对象头中包含了一个MarkWord,包含了对象的GC年龄,hashCode,线程ID,偏向锁标识,锁标记等。
  - 偏向锁:某个线程去获取锁时候,将自己的线程ID通过Cas设置到锁对象中,如果设置成功,代表获取到偏向锁,如果下次该线程再次获取这把锁的时候,比较锁对象中的线程ID是否和该线程的线程ID相同,如果相同那么直接拿到这把锁,否则进行锁的升级。
  - 轻量级锁: 某个线程获取锁的时候会将锁对象的markword 复制到自身的lockRecord上,然后在通过cas将锁对象的markword替换成自身的锁记录,如果替换成功.那么证明获取到轻量级锁,否则会进行一个适应性自旋来获取锁,如果一段时间后仍然获取不到,那么就升级为重量级锁。
  - 重量级锁:(调用操作系统底层的互斥锁进行同步操作)每个对象都有一个monitor监视器对象,并且存在几个队列。 
    - 竞争队列: 如果存在多个竞争锁线程,其是先进后出的一个队列。
    - 候选队列:  获取到锁的线程会从竞争队列尾部选取一个线程进入候选队列,并指定某一个线程去竞争锁,与未入队进行自旋获取锁的线程互相竞争。
    - 等待队列: 调用对象的wait方法会进入等待队里。
    - 竞争锁线程: OnDeck
- **ReentrantLock**
  - 是JDK提供的一个锁工具类,基于AQS实现的。
  - 加锁流程？
    - Aqs中有一个state变量,标识锁的状态,ReentrantLock在加锁时候,通过cas将state变量从0变为1,如果cas操作成功,并设置当前线程ID,证明获取锁成功。
    - 如果cas失败,在进行一次获取锁,并判断是否是锁重入,如果是当前锁冲入那么将state加1,获取锁成功
    - 如果再次获取锁失败,那么加入到等待队列,进行阻塞等待。Lock.Support.
- **Synchronzied 和 ReentrantLock区别？**
  - Synchronized 是非公平锁,ReentrantLock支持公平锁以及非公平锁。
  - Synchronized是jdk提供的一个关键字,RenntrantLock是java并发包下提供的类。
  - Synchronized在线程竞争激烈的情况下没有ReentrantLock高。
  - Synchronized 一直堵塞到获取到锁,ReentrantLock可以设置一个超时时间进行尝试获取锁。
  - ReentrantLock可以进行响应中断,synchronized不行。

- ****谈谈你对AQS的理解？**
  - AQS其实就是JDK提供的一个抽象队列同步器,可用于实现基于先进先出的等待队列的锁和同步器的框架,比如ReentrantLock、FutureTask、CountDownLatch等都是基于其实现的,该抽象类实现了线程的入队,出队等操作,所以我们只需要实现获取锁的逻辑,以及释放锁的逻辑即可。

#### Redis

- Redis**有哪些结构**？
  - string: 动态字符串, 预分配空间,维护了一个字节数组,分配了一定的空间,减少内存的频繁分配.字符串长度小于1M时,扩容是翻倍的现有空间,大于1M,扩容是扩展1MB的空间。
  - hash: 类似于java中的hashmap,基于数组+链表的结构。
  - list: 列表类似于java中 LinkedList,注意其是链表而不是数组。意味着ist的插入和删除操作非常快。
  - set: set集合,类似于java中的hashset,内部实现也是一个字典,每一个value是一个null
  - zset: 有序列表,  跳表。 类似于SortSet和HashMap的结合体。一方面它是一个set,保证了内部value的唯一性,另一方面value设置一个分值,用来进行排序。  单链表的某些节点的上层增加一些索引节点。
- **Redis过期key是如何清理的？**
  - 惰性清理:在访问key的时候,发现其已经过期,那么将其删除
  - 定时清理: 每次遍历所有的DB,从DB的过期字典里随机筛选出20个key,如果超过25%的key已经过期,那么继续对这个db进行清理,否则对下一个DB进行清理。
  - 内存不够时候进行清理:
    - 直接报错
    - 从所有结果集中进行淘汰:
      - 随机淘汰算法
      - LFU算法,使用频率最低的key。
      - LRU算法,最近最久未使用的key进行清理。
    - 从淘汰列表中进行淘汰:
      - ~~
- **Zset是怎么执行查询操作的？**
  - Zset是基于跳跃表+字典实现的.
    - 如果只是单key查询,那么就直接从字典中进行查询.
    - 跳跃表查询,首先根据要查找节点的分数与顶层的节点的分数进行比较,不断索引查找索引节点的区间,一层一层的向下查找,直到找到与这个节点相同的节点
- **Redis为什么是单线程的以及为什么这么快？**https://www.jianshu.com/p/bc6904abc330
  - Redis是纯基于内存的,处理请求速度非常快,不需要使用多线程提高其的CPU利用率。CPU不会成为瓶颈。
  - 这里单线程指的是处理客户端发送的请求命令的处理器模块是单线程,而有些模块不一定是单线程的。
  - 只有IO才是影响Redis服务器性能的主要因素,而Redis采用了IO多路复用模型,尽量减少网络 I/O 的时间消耗。减少了线程的切换。
- **聊聊IO多路复用模型？**
  - 单个线程处理多个socket连接请求,减少系统开销,不必创建过多的线程。
- **Redis缓存穿透？**
  - 缓存穿透指的是攻击者故意大量的请求一些缓存中不存在的key,从而导致大量请求打入到DB,从而导致了DB崩溃。
    - 解决方案:
      - 参数校验（总会绕过这些参数进来） 
      - 对DB不存在的key也进行一个缓存,失效时间可以设置小一点,比如几秒钟,可以避免大量的请求打入DB。
- **Redis缓存击穿？**
  - 某个热点key失效造成了大量的请求打入DB。
    - 解决方案：
      - 每次请求的时候去判断缓存剩余时间,如果缓存剩余时间小于设置的缓存时间的一半去更新缓存。
      - 热点key,可以使用两个key例如A和B进行存储,两个key的缓存时间不同,如果A查不到去查B,同时在去更新两个key的缓存值。
- **Redis缓存雪崩?**
  - 缓存雪崩指的是大量的key失效,导致流量一次又一次的打进Redis服务器,导致Redis一直垮掉。
    - 解决方案:
      - 原有的失效时间上增加一个随机值,避免了采用相同的过期时间导致的缓存雪崩。
      - 熔断机制,当请求达到一个阈值的时候,直接返回。保证有一部分用户可用。
- **Redis缓存与数据库一致性问题如何解决？**
  - 延时双删: 先更新数据库,然后删除缓存,然后再启用一个异步线程进行延时删除缓存,保证缓存的值是最新的。
- **Redis持久化如何实现的？**
  - **AOF**:
    - 将Redis的操作命令追加写入到AOF文件中。
  - **RDB**:
    - RDB是在一定条件下.对这个数据库某个时间点所有的键值对信息生成一个压缩文件,然后将旧的删除,新的替换掉。
- **AOF和RDB的区别？**
  - AOF是保存了所有的执行修改命令,粒度更细,进行数据恢复的时候,恢复的数据更加完整,但是由于需要对所有的命令重新执行一遍,所以效率没有RDB的方式高。因为是所有的修改命令,所以同样的数据集,aof文件也会比RDB文件大一些。
  - RDB就是保存了某一个时刻DB所有的键值对的信息,恢复效率比较高。
- **AOF如何防止文件越来越大？**
  - 进行AOF重写,生成此刻的DB数据所需的写命令并写入AOF文件。生成期间,父进程可以正常进行处理请求,将命令写入aof_buf缓冲区,然后在将其写入到新的aof文件中,并原子的替换掉原先的AOF文件。
- AOF持久化方式？
  - 混合持久化,AOF文件前半段是RDB,后半段是AOF文件。

- Redis集群方案？https://github.com/NotFound9/interviewGuide/blob/master/docs/RedisUserful.md
  - 主从：全量同步,部分同步
  - 哨兵：运行在哨兵模式下的Redis服务器,核心功能是检测主节点和从节点的运行情况,如果主节点宕机,让某个从节点变更为主节点。
  - 集群：no know

- **跳跃表与平衡树,哈希表的比较？**
  - 时间复杂度：单key查找时,跳跃表和平衡树的查找时间复杂度 ologn,哈希表 o1.
  - 空间复杂度：平衡树的节点包含两个指针,跳跃表的节点指针与其节点有几层的概率相关。redis默认的跳表指针就是1.33。  1 / 3/4
- **为什么Mysql不是用跳跃表作为索引？**
  - 磁盘IO的开销,B+树的一般是2到4层,而跳表查找一个Score对应的位置需要进行log(n)次的操作,如果所有的索引节点都存在磁盘中,那么也就需要logn次的磁盘IO。
- **为什么平衡二叉树也不适合作为索引？**https://www.cnblogs.com/aspirant/p/9214485.html
  - 平衡二叉树指的是逻辑上的结构,而物理结构其实就是数组,逻辑结构上相近,但是物理结构上却不一定相近,当查找数据的时候,平衡二叉树可能会查出很多没有用的数据,会导致更多的磁盘IO,导致性能下降。

#### Mysql

- ​	一条Sql语句执行发生了什么?
  - 连接器->分析器->优化器->执行器
  - 首先写undolog-记录下执行语句的回滚日志,用来MVCC,回滚。
  - 如果查找的目标数据存在于内存中。
    - Yes:
      - 判断是唯一索引还是普通索引
        - 唯一索引,判断唯一索引是否冲突并更新内存
        - 普通索引,直接更新内存
    - No: 磁盘
      - 唯一索引,从磁盘读到内存,判断冲突与否并更新
      - 普通索引,变更到changeBuffer
  - 写Redo log
  - 写bin log
  - 提交事务
  - 刷redo log盘
  - 刷bin log盘
- 聊聊索引？
  - 索引是一种对数据库表中一列或者多列数据进行排序的存储结构,能够通过索引快速的定位到数据中的某条数据。
  - Mysql中的索引分为聚簇索引和非聚簇索引。聚簇索引也就是主键索引,主键索引的叶子节点包含的时数据库某一行的数据,而非聚簇索引也就是二级索引,叶子节点存储的时主键的值。
  - Mysql有唯一索引、联合索引、普通索引。
    - 唯一索引:DB数据该字段的值时唯一的
    - 联合索引:多个字段组成一个索引,遵循最左前缀原则,遇到范围查询就停止
  - 覆盖索引: 查询的字段都在索引上,叫做覆盖索引,无需回表
  - 哪些字段需要建立索引？
    - 经常用作查询条件的
    - 与其他表相关联的字段
    - 需要排序,统计,分组的字段
  - 哪些字段不需要建立索引？
    - 区分度不高的字段
    - 数据量较少的表
- 聊聊Sql优化？
  - 首先我们在优化sql的时候要查询他的执行计划,通过explain语句,有一个extra字段
  - 如果是 use index证明使用索引,如果是use where 证明没有使用索引
  - use fileSort 代表排序的字段没有添加索引,结果集生成后在进行排序,可以在排序字段增加索引
  - 减少扫描行数,通过执行计划中扫描行数来添加合适的索引来减少扫描行数
  - join字段也要加索引,采用索引嵌套连接方式。
- Mysql事务的实现以及原理？https://cloud.tencent.com/developer/article/1431307
  - 事务的原子性是通过undolog来实现的
    - 回滚日志,如果有异常那么就执行回滚日志,返回之前的数据。
  - 事务的持久性是通过redolog来实现的
    - redo log是同步存储,而缓存同步是 随机操作也就是数据写入到文件中
    - 缓冲池,避免性能消耗
  - 事务的隔离性是通过读写锁+MVCC实现的
- Mvcc实现的原理是什么？https://github.com/NotFound9/interviewGuide/blob/master/docs/MySQLNote.md
  - Mysql每行数据有隐藏的两列,一列时事务ID,一列是回滚指针,指向undolog
  - 查询的时候,如果
- Mysql死锁实践？
- 设计数据库表的思路？

#### Mq

#### Dubbo

#### Zookeeper

#### Es

#### Apollo

#### Spring

#### 实践

