#### Es

- https://mp.weixin.qq.com/s/2LZ6zWe5ohQJl7GiZ52Vxg
- Mysql索引使用B+Tree,聚集索引对应对应数据记录,二级索引的叶子节点也是关联的主键索引。
- 倒排索引：正常的索引都是ID 对应某条记录的内容,而倒排索引呢就是某条记录的某个字段值,对应着不同的ID。

### Es写数据的过程？

1. 客户端选择一个节点发送请求过去，这个节点就是协调节点。
2. 协调节点会对 文档进行路由，将请求转发给对应的节点 （主分片）。
3. 然后对应节点的主分片处理请求，然后同步给从节点
4. 协调节点发现 主节点和从节点都写完之后，再响应结果返回客户端

### Es读数据的过程？

- 通过文档ID进行查询，根据文档ID进行hash，判断出来当时把文档ID分配到了哪个分片上去，从那个分片进行查询。
- 客户端发送请求到任意一个节点,成为协调节点
- 协调节点对文档id进行hash路由，将请求转发到对应的节点，此时使用轮询算法，在主节点和分节点选取一个，让读请求进行负载均衡。
- 接收请求的节点返回文档给协调节点。
- 协调节点把文档给客户端。

### Es搜索数据的过程？

- 客户端发送一个请求到协调节点
- 协调节点把搜索请求发送到所有分片对应的主节点或者从节点
- 每个分片进行搜索，然后返回给协调节点
- 然后协调节点进行合并，排序，分页等操作。
- 最终返回给客户端

### Es写数据底层原理？

- 先写入内存buffer,然后每隔1s,写入操作系统缓存，然后客户端可以查到,
- 每隔5s写入tranSlog文件中,tranSlog 大到一定程度或者每30分钟
- 会将tranSlog的数据进行一次提交，刷新到磁盘中。

### Es 分页方式？

- 常见的from+size方式:
    - 深度分页的情况下效率很低,比如from=5000,size=10,es需要在各个分片上匹配排序并得到5000条有效数据,然后在结果集中取最后10条数据返回。
    - es默认支持最大的结果窗口值为10000条。 也就是from+size大于10000的时候,es将返回错误。

- scroll分页方式
    - es通过scroll的分页方式进行查询,原理是回生成一个scroll_id 其实是对应在内存里生成的一份快照，后续根据scroll_id去取数据,不适合实时查询。
    - 快照占用内存,使用完应该及时清理

- search_after:
    - 根据上一页的最后一条数据来确定下一页的位置,同时在分页过程中，如果有索引数据的增删改查,这些变更也会实时的反映到游标上。
    - 依赖于每个文档需要有一个全局唯一的ID。

### Es 线上遇到过什么事故么？

- 一共遇到过两次一次是自己的操作,另一次是同事操作导致的。
  有一次我做一个评价列表的需求,通过es查询,有一个条件是要筛选出大于几个字的评论,然后呢就用了一个函数,来对那个字段进行一个筛选,当时出现了一个问题,就是有些评论显示不出来,后来查日志才发现,是否个分片异常了,导致那个分片的数据没有查出来,因为Es是一个分布式的中间件,他的数据都分散在不同的分片上。~~~
  Es的查询请求。 后来用了正则表达式解决的这个问题。
- 另一次是有一个同事使用了Es的深度分页导致了 Es内存打满,导致大量应用请求超时,然后后来排查,是那个同事改了
  Es的默认最大窗口值,当时运维没有限制这个参数,那个同事给改了很大的值，然后呢,当时有个运营就点了最后一页，肯定刷的慢,当时他肯定是点了很多次，最后导致内存崩了。