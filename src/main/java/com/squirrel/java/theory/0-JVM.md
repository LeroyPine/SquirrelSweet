### JVM内存结构？

### JVM类的加载机制？

- 首先将.java文件编译成.class文件
- 然后将其读进内存
- 然后进行Jvm验证、准备、解析、初始化等操作
- 准备的话就是为类变量分配内存空间以及默认值
- 解析的话就是将class文件中的符号引用转换成直接引用,指向类对象的地址和类方法的地址
- 然后就是进行类初始化。

### JVM类加载器以及双亲委派机制？

- BootStrapClassLoader :启动类加载器
- ExtensionClassLoader: 额外包类加载
- ApplicationClassLoader:应用程序类加载器
- CustomerClassLoader:用户自定义类加载器

### 什么打破了双亲委派机制？

- SPI机制:第三方厂商
- Tomcat类加载机制:部署不同的服务,Jar不同,所以每个服务要有自定义的类加载机制

### 常量池和运行时常量池？

- 常量池是.java文件编译为.class文件后,存储的符号引用
- 运行时常量池是jvm类加载完成后将符号引用值指向转存到运行时常量池,在解析阶段将符号引用替换为直接引用。(包含字符串常量池)

### New一个对象发生了什么？

### 如何确定一个对象是否可以被回收？

### 垃圾回收算法有哪些？

### CMS垃圾回收机制？

### G1垃圾回收机制？

- G1是将内存区域按照region一个个划分出来,然后回收的时候按照用户设定的回收时间,优先回收那些回收价值大的区域。(G1会维护一个垃圾回收的优先列表)
- 同样具有年轻代和老年代,G1垃圾回收器的目标是能够在  **用户设定的延迟时间内**获得尽可能高的吞吐量。至于回收过程和CMS类似:初始标记、并发标记、重新标记、并发清理

### JVM有哪些参数？

- 堆
    - -Xms:初始堆大小
    - -Xmx:最大堆大小
- -Xmn:年轻代大小---整个堆大小=年轻代大小 + 年老代大小 + 持久代大小. eden+ 2 survivor space
- -XX:PermSize:方法区大小
- -Xss:线程栈大小: 512K
- -XX:SurvivorRatio:Eden和Survivor比例
- -XX:+PrintGCDetails:打印GC详细信息
- -XX:+UseConcMarkSweepGC:使用CMS

### GC时间过长如何分析？

- https://segmentfault.com/a/1190000023937207

