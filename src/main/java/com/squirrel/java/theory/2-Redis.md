### Redis是什么？

- Redis是一个基于内存的非关系型数据库

### Redis过期key的清除策略？

- **惰性清除**:在访问key时,如果发现key过期,那么将key删除
- **定时清除**: 每次清理会遍历DB,从DB维护的过期字典中,随机去除20个key.如果过期就删除。如果其中5个key过期,说明过期率超过了25%,那么继续对这个db进行 清理。否则开始清理下一个db
- **内存不够时进行清理**：一般有6种方式：
    - 不处理,等报错
    - 从所有结果集中的key进行挑选,进行淘汰（随机,lru,lfu）
    - allKeys-random：从所有的key中随机挑选key,进行淘汰
    - allKeys-lru：从所有的key中挑选最近使用时间距离最远的key,进行淘汰
    - allKeys-lfu: 从所有的key中挑选使用频率最低的key,进行淘汰。
    - 从设置了过期的key中挑选,进行淘汰 （随机,lru,ttl,lfu）
    - 这种就是从设置了过期时间的结果集中选出一部分key淘汰,挑选的算法有： - ttl：设置了过期时间的结果集中挑选可存活时间最短的key开始删除

### Redis为什么是单线程的？

- Redis是基于内存的操作,读取数据很快,CPU不是Redis的瓶颈,单机可以支持每秒几十万的请求,不需要在某个线程读取数据的时候,切换另一个线程来提供CPU利用率。
- **单线程优势**：单线程的情况下,无需考虑各种锁的问题,不存在加锁释放锁等操作。
- **单线程劣势**：无法发挥多核CPU的优势,不过可以在机器上启动多个REDIS实例来利用资源。但是多个Redis可能会导致在进行AOF重写时, 竞争IO资源,导致磁盘压力
  过大,但是可以通过脚本来触发实例的AOF重写。耗时的命令会导致并发的下降，不只是读并发，写并发也会下降。

### Redis为什么性能这么高？

- 完全基于内存
- 单线程,没有锁的竞争与消耗,减少了线程的上下文切换
- redis的数据结构也是经过一些优化的,比如string,预分配了空间,避免了扩容带来的开销,还有list,采用了压缩列表,对短数据进行了压缩存储。
- 采用IO多路复用模型:redis采用**epoll**监视多个Socket连接, 如果空闲的时候,那么会将当前线程挂起,当有一个或多个事件的时候, 当前线程就会轮询这些发出事件的流,并依次的处理就绪的事件流
  ,核心单个线程高效的处理多个Socket连接。

### Redis的事件模型？

- Redis分为文件事件和时间事件。
    - 文件事件:**文件事件是对多个socket进行多路复用而产生的的事件为文件事件**,包括了读事件和写事件
        - 读事件:实现了对客户端请求命令的接收
        - 写事件:实现了对请求命令结果的返回
        - 读写事件同时存在的时候,优先处理读事件
    - 时间事件:记录了Redis服务器中需要在指定时间点运行的事件,多个时间事件以无序链表的方式保存在服务器状态中。
        - 清除过期key
        - AOF或者RDB等操作
        - 统计服务器各类统计信息,内存占比等。

### Linux中IO模型一共有哪些？

- IO 模型主要由 阻塞式IO模型,非阻塞式IO模型，IO复用模型,信息驱动IO模型,异步IO模型
- 阻塞式IO-- 也就是BIO,Blocking IO:  用户发出一个IO请求,等待服务器处理完返回,用户线程要处于阻塞状态.
- 非阻塞IO-

### Redis缓存穿透如何解决？

- 含义：故意大量请求一些Redis中不存在key的数据,导致请求打到数据库上

- 对无效的参数进行校验,无效的请求直接返回。
- 对于缓存中找不到的key,需要去数据库查找的key,缓存到Redis中,但是可能会导致Redis中缓存大量无用的key,可以设置一个很短的过期时间。

### Redis缓存击穿？

- 含义：某个热点key失效,导致请求全部转入数据库,导致数据库压力过大
- 对热点key设置永不过期
- 加锁,缓存中没有热点key对应的数据时,设置个等待时间,由获得锁的线程去读取数据库然后设置缓存。

### Redis缓存雪崩？

- 含义：短时间内大量key失效
- 给缓存设置失效时间加一个随机值,避免集体失效
- 双缓存机制,缓存A的失效时间为20分钟,缓存B的失效时间比A长一些,从缓存A读取数据,缓存A中没有时,去缓存B中读取数据,并且启动一个异步线程 来更新缓存A,以及更新缓存B,以便延迟B的过期时间。

### 如何解决缓存与数据库的数据一致性问题？

- 延时双删策略,先修改数据库,然后删除缓存,在通过一个延时消息在删除这个key,保证下次查询的时候,会把DB的最新值缓存在缓存服务器上。
- 可以基于binlog的模式,监听DB某个字段的变化来进行延时双删的策略。

### Redis事务机制？

- Redis的事务可以看做是批量redis命令的一个执行,批量执行也并非原子性,就是说如果批量指令中有一个命令报错了,那么其也不会进行回滚`multi  set key value exec`
- 只有在语法错误的时候,redis执行前会进行一个校验,不让其进行执行。

### Redis分布式锁？

- 简单一点的分布式锁,就使用redis.setNx的命令，一般我们是用redisTemplate的方法,他的加锁保证了添加key和过期时间在一个原子操作里。然后我们需要考虑锁释放的问题,
  因为我们不能让别的线程去解锁当前线程,所以在设置分布式锁的时候一般value会设置一个uuid,然后解锁的时候用这个去对比解锁,如果相同的uuid才可以对其进行解锁,防止其他线程将锁解除。
- 存在的一些问题就是:
    - 如果锁过期了,锁就会被释放掉了
    - 简单的锁不支持重入
    - 并发量大的情况下,好多请求会失败,可以自己实现一个自旋锁,去获取锁。

### Redis使用场景？

- 在定时任务中用作分布式锁。避免同一个任务多次执行
- 简单的限流器
    - 场景:评价后台导出数据量太大,导致服务OOM,因为当时导出的时候没做限制,用户点击了很多次导出,导致服务内存被打满。
        - 通过redis-setNx()做了一个简单的限流器。
        - redis-setNx,设置一个过期时间,然后value为要限制的请求数量。 每次setNx失败后,将请求数量减-1,如果数量仍然大于0,那么可以进行执行。否则不可以
        - redis-zSet,滑动窗口,key | value(uuid) | score(当前时间戳)  --可以通过redis zSet提供的一个方法可以统计某(时间段)范围内的请求数量。
          zRangeScore可以统计分数区间内的元素个数 zRangeScore(key,systemTime-intervalTime,currentTime)

### Redis 数据结构？

- string:动态字符串
- list:集合
- hash:哈希
- set:集合
- ZSet:跳表

### 用过哪些数据结构呢？

- 常用的就是string
- 然后也用过sortSet,做了一个排行榜(每天NPS得分最高的50名管家)

### 谈一谈你对Redis中简单动态字符串的理解？

- sds动态字符串,不同长度的字符串使用不同的结构体来进行表示, 如果value是一个整数,并且可以使用long类型来表示时,那么就属于int编码。直接存储数值
- sds动态字符串同事有内存预分配和惰性空间释放:
    - 如果字符串实际使用长度len<1M,实际分配空间= 分配len长度来作为预分配空间
    - 如果字符串实际使用长度len>1M,实际分配空间= 分配1M空间作为预分配空间
- 字符串可以保存一些字符串数据,也可以保存一些数字类型的数

### 谈谈你对Redis中hash对象的理解？

- value 可以是一个hash表,底层可以使 zipList 也可以是 hashtable,当元素小于512时,底层使用zipList
- zipList：元素保存的字符串长度较短且元素个数较少时候,出去节约内存考虑,hash表会使用zipList作为底层的实现,zipList是一块连续的内存,里面 每一个节点
  保存了对应的key和value,然后每个节点很紧凑的存储在一起,有点事没有冗余空间,缺点是插入新元素需要扩展内存。
- hashtable：元素比较多时就会使用hashtable,底层是一个字典数组,保存了 两个数组,通常第一个数组保存数据,第二个数组在扩容时用到,hashtable通过链地址法来解决冲突的,
  table数组存储的是链表的头结点,添加元素时,根据键计算出hash值,与数组长度取模后得到数组下标,将元素添加到数组下标对应的链表中去。

- 渐进式rehash：当负载因子>=1时,会进行哈希表扩展操作,如果实在执行BGSAVE 或者 BGRewriteraof 命令期间,那么需要>=5 才会进行扩展
- 当负载因子<0.1时,会进行哈希表收缩操作。直接一次性完成rehash会对性能产生影响
- 初始化：1.首先对dict结构中得 第二个数组分配空间 2.转移过程不是全部转移,未全部转移完成前还是用第一个数组 进行指令操作,找不到才会去 第二个数组,每次用到某个下标下的键值对才进行转移这个下标下所有的键值对.
  然后.每次对第一个数组进行操作时,同时将对应下标的所有键值对 rehash到第二个数组中. 3. 更改指针指向,当第一个数组的键值对全部rehash到第二个数组中,那么指针进行交换。

### 谈谈你对Redis中List的理解？

- 在Redis中,存储的value可以是一个列表List,跟Java中的LinkedList很像,底层数据 结构是一个链表,插入和删除很快,随机访问很慢,时间复杂度时On,Java中的列表数据进行缓存时
  一般是序列化成JSON。而不是使用Redis中的List进行存储。Redis中的list可以作为一个队列来使用,也可以作为一个栈使用,在使用过程中,常用来做异步队列使用。

- QuickList：是一个双向链表,但是每个节点是一个zipList。 默认最大长度为8k

### 谈谈你对Redis中set的理解？

- Set是一个无序的,不重复的字符串集合,底层编码有 inset 和 hashtable 两种
- inset 当元素都为正数,且元素个数较少时会使用inset,inset结构中有一个 content属性,一个整数数组,从小到大保存了所有元素
- hashtable 使用hashtable保存元素 值为key value为null

### 谈谈你对Redis中ZSet的理解？

- ZSet的每个元素有一个Score的属性,存储元素的时候会根据score值由小到大进行排列,底层通过跳跃表实现。
- 当元素较少时,元素个数小于128,ZSet底层编码使用zipList实现,所有元素按照Score从低到高排序
- skipList + dict:  当元素过多时候,使用skipList+dict实现,skipList 存储元素的值和score,并且将所有元素按照分值有序排列, 便于以 O
  logN的时间复杂度插入、删除、更新、以及根据Score进行范围性查找。 dict 存储的是元素的值以及score的映射关系。

### 谈谈你对跳跃表的理解？

- 在单链表的基础上增加一些索引节点
- 其实就是**单链表**的查找的时间复杂度为On,为了提高查找效率,可增加一些索引节点,让查询时间复杂度降低为OLogN,只有底层单链表会保存节点数据,
  上层的节点之后保存几个索引项以及分数,也就是左指向前一个节点的索引,向右指向后一个节点的索引,向下指向上一级的索引。 log(n)
- Redis会计算出一个随机数,代表这个节点添加的索引层数,然后进行添加。
- 最大32层，Redis中配置一个概率 0.75 计算总层数时候：有1/4的概率层数+1,3/4的概率层数不变。
- 作为一种动态的数据结构,删除和添加节点是不可预测的,而跳跃表又不能像平衡二叉树那样,可以通过染色或者旋转来维持平衡,如果严格按照
  两个节点之间建立一个索引,在删除和添加节点时候,需要更新太多的索引,所以就需要一种概率随机化的方式在自动均衡跳跃表的多级索引, 通过这种方式虽然不能完全保证跳跃表的均匀性,但总体上可以是的跳跃表趋于平衡, 从而达到较高的综合性能。

### 跳跃表与平衡树,哈希表的比较？

- 单key查找时,跳跃表和平衡树的时间复杂度为 O log N ，哈希表为O 1
- 范围查找： 平衡树找到区间之后： 还要进行中序遍历
- 删除和插入节点之后,平衡树需要进行左旋,右旋,进行调整保证平衡性,而跳跃表只需要修改相邻节点的指针,然后计算这个新增节点的层数。
- 内存占用上：跳跃表平均指针1.33,平衡树指向左右子树2个指针

### 为什么Mysql不使用跳跃表作为索引？

- 主要是因为磁盘的IO次数, mysql对应的数据量比较大,可以达到几千万级别,不可能全部加载到内存中,而redis是这个基于内存的数据库
- 每一次IO读取的数据我们称之为页 page,具体一页多大跟操作系统有关,一般为4k或者8k innodb一般为16k,而一般 innodb的B+数一般是2到
  4层,也就是最多进行2到4次磁盘IO,如果跳跃表的节点都存在磁盘中,那么也就需要log n 次的磁盘IO。

### 为什么平衡二叉树不适合作为索引?

- 平衡二叉树的查找效率与其深度有关,而且在物理结构上,相近的节点可能不同,查出来也用不到,因此查找过程中可能要进行更多次的磁盘读取操作。

### 跳跃表是怎么执行查询操作的？

- ZSet是基于跳跃表和字典实现的,如果只是单key查询,m那么直接在字典中查询。
- 跳跃表的查询 ： 如果有多层索引,首先遍历首层,找到合适的位置,比如查14,首层索引有个10 和 18 ,从10节点向下查找,

### Redis的持久化是怎么实现的？

- 因为Redis是基于内存的数据库,一旦断电,所有实例都会down,数据都会丢失,在运行期间,可以通过开启Redis的持久化功能 ,将数据写入磁盘,供实例重启时恢复数据,Redis的持久化主要通过AOF和RDB实现持久化

- AOF 持久化
    - Redis命令写入文件中,可以配置写入策略,一般每秒写入。

- RDB
    - RDB持久化指的是在满足一定的触发条件下,在一个时间间隔内执行修改命令打到一定的数量,或者手动执行save和bgsave命令,对这个时间点的数据库所有键值 对信息生成一个压缩文件,然后删除旧的dump,进行替换.
    - fork 一个子进程
    - 通过 fork 创建的子进程能够获得和父进程完全相同的内存空间，父进程对内存的修改对于子进程是不可见的，两者不会相互影响；
    - 通过 fork 创建子进程时不会立刻触发大量内存的拷贝，内存在被修改时会以页为单位进行拷贝，这也就避免了大量拷贝内存而带来的性能问题；

- AOF和RDB的区别是什么？
    - AOF是保存了所有执行的修改命令,粒度更细,进行数据恢复的时候,恢复的数据更加完整,由于对所有的命令执行一遍,效率较低,同样是
      保存了所有的修改命令,同样的数据集,保存的文件会比RDB大,而且随着时间的增加,AOF文件可能会越来越大,所以会执行重写命令来重新生成AOF文件 ,减小文件大小。
    - RDB 保存的某一个时间点的所有键值对的 信息,所以恢复时可能会丢失一部分数据,但是恢复效率会比较高。

- 怎么防止AOF文件越来越大？
    - 为了防止AOF文件越来越大,可以通过BgWrite-AOF进行AOF重写,会fork出子进程来,读取当前数据库的键值对信息,生成所需的写命令,写入
      新的AOF文件,在生成期间,父进程继续正常处理请求，执行修改命令后,会写命令写入aof/-buf缓冲区,还会写入重写aof-buf缓冲区,待新的aof 文件生成后,将重写aof—buf写入新的aof文件。

- 持久化策略：
    - 混合持久化：首先将共享内存的副本全量的以RDB方式写入aof文件,然后增量的命令以AOF写入到文件。最终将含有两种格式的文件替换旧的AOF文件。

### Redis 集群

- Redis主从同步是怎么实现的？
    - 主从节点建立连接后：
        - 从节点之前从没同步过数据：属于初次复制,会进行全量复制
        - 从节点不是初次复制,会将之前同步的replication ID 和 offset 通过pSync id offset命令发送给主节点,主节点会进行判断。
    - 全量同步： rdb + 命令
        - 部分同步:  命令

- Redis中哨兵是什么？
    - 哨兵服务器是一个运行在哨兵模式下的Redis服务器,核心功能是监测主节点和从节点的运行情况,在主节点出现故障后,完成自动故障转移,让某个从节点 升级为主节点。
    - 在实际开发中,通过在客户端配置哨兵节点的地址+主节点名称。

### Redis哨兵系统如何实现自动故障转移的？

- 哨兵节点会给主节点发送ping命令,如果没有收到回复,那么哨兵节点认为主节点主观下线
- 哨兵节点向其他哨兵节点发送主节点下线命令,获取其他哨兵节点对该主节点的状态,当认定主节点下线的哨兵数量达到一定数量时,那么就认定 主节点客观下线。
- 领导者哨兵选举： Raft算法：
- 领导这哨兵进行故障转移：
    - 先排除一些不健康的节点： 根据优先级,复制偏移量 选出一个从节点作为主节点
    