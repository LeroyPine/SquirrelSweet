https://zhuanlan.zhihu.com/p/341638244

### Dubbo是什么？RPC又是什么？

- Dubbo是一个分布式服务框架,致力于提供高性能和透明化的RPC远程服务调用方案,以及SOA服务治理方案。

### Dubbo能做什么？

- 远程通信
    - dubbo-remoting 模块提供了多种基于长连接NIO框架的抽象封装,包括多种对线程模型、序列化以及请求-响应模式的信息交换方式
- 集群容错
    - 提供基于接口方法的透明远程过程调用，包括多协议支持,以及软负载均衡、失败容错、地址路由、动态配置等集群支持。
- 自动发现
    - 基于注册中心目录以及服务,支持服务消费方动态查找服务提供方,地址透明，支持服务提供方平滑增加或减少机器

### Dubbo的总体调用流程？

(白话文)

- 服务启动,加载运行服务提供者
- 服务提供者向注册中心注册服务
- 消费者启动,从注册中心拉取全量服务到本地,如果服务发生变化,会推送变更数据给消费者
- 通过负载均衡,路由等在服务列表中选取一台进行调用
- 如果调用失败,会进行重试等操作。

### 说说Dubbo支持哪些协议,每种协议的应用场景和特点

- Dubbo:单一长连接和NIO异步通讯,适合大并发数据量小的服务调用,以及消费者远大于提供者
- http:基于HTTP 多个短连接
- redis:发送订阅机制,通过list实现
- rmi:jdk 版本
- Hession:
- webService:

### Dubbo中用到哪些设计模式？

- 责任链模式：Dubbo的调用链组织是用责任链模式串起来的,责任链中每个节点实现Filter接口,然后由ProtocolFilterWrapper 将所有Filter串联起来
- 观察者模式：**Dubbo的provider启动时，需要与注册中心交互，先注册自己的服务，再订阅自己的服务，订阅时，采用了观察者模式，开启一个listener
  注册中心会每5秒定时检查是否有服务更新，如果有更新，向该服务的提供者发送一个notify消息，provider接受到notify消息后，即运行NotifyListener的notify方法，执行监听器方法。**
- 修饰器模式：ProtocolFilterWrapper 类是对Protocol类的修饰,在export和refer方法中,配合责任链模式Filter组装成责任链,实现对protocol功能的修饰
- 适配器模式：dubbo 日志设置
- **代理模式**:Dubbo为服务提供者和生产者都生成一个代理.使用这个代理去进行请求

### Dubbo中provider提供的服务有多个版本怎么办？

- 我们可以针对dubbo的方法进行版本的控制,此时dubbo回去寻找对应的版本

### 服务暴露的过程是怎么样的？ ServiceBean

- dubbo服务导出是基于Spring容器刷新事件,Dubbo在接收到事件之后,会执行服务导出逻辑
- 首先是读取dubbo配置并将其组装成一个完整的URL.
- 然后就是导出服务,分为**导出在本地**以及**导出在远程**
- 首先由代理工厂创建invoker,包含了服务地址以及接口方法等信息,然后invoker在转换成exporter
- 启动本地服务,监听消费者的请求
- 最终向注册中心注册自己的服务.

### 服务引用的流程是怎么样的？ ReferenceBean

- 首先,客户端根据config文件信息从注册中心订阅服务,首次全量缓存到本地,后续的更新会通过监听动态更新到本地
- 消费者会根据provider的地址和接口信息连接到服务端server,开启客户端client,然后创建Invoker
- 通过invoker 为服务接口生成代理对象,这个代理对象用于远程调用 provider,至此完成了服务引用

### Dubbo的注册中心有哪些？

- Zookeeper、Redis

### 聊聊Dubbo的SPI机制

- SPI是一种服务发现机制,通过将类的全限定类名写入配置当中,在服务加载的时候读取配置文件,加载实现类，就可以在运行的时候,动态帮助接口替换实现类。
- DubboSPI 支持按需加载,dubbo的配置文件里面是通过kv的形式,dubbo在加载的实现类的时候,通过在dubbo的配置中进行选择加载。
- 同时增加了对扩展点IOC和AOP的支持,一个扩展点可以直接setter注入其他扩展。

### Dubbo 负载均衡？

- 加权随机：请求均匀分配
  - 给每台机器设置权重 A：4 B：5 C：6 总和15
  - 0-4 A 4-9 B 9-15 C

- 最小活跃数：
  - 每个服务提供者对应一个活跃数,默认情况下 所有服务提供者活跃数都为0，每收到一个请求 活跃数+1 完成请求后活跃数-1。
  - 活跃数小的服务器证明其处理请求速度快。

- 加权轮询
  - 轮询

- 一致性hash
  - 映射Invoker:将服务提供者的ip+端口进行一个MD5,然后在增加一个虚拟节点进行hash,存入Treemap中
  - 映射请求:根据请求的参数值进行计算hash值,找到第一个大于此hash值的invoker,然后进行调用,Treemap中存在ceilingEntry(hash),获取比传入值大的第一个元素.

### 集群容错的方式有哪些？

- Failover Cluster ： 失败自动切换： dubbo的默认容错方案,当调用事变时自动切换到其它可用的节点,具体的重试次数和间隔时间可以通过引用服务的时候 配置，默认重试1次。
- Failback ：失败自动回复, 定时5s 对失败的任务进行重试
- Failfast Cluster： 快速失败：只调用一次,失败后立刻抛出异常
- FailSafe ：记录日志不抛出： 返回空结果
- Forking Cluster ： 并行调用,线程池并发 如果有返回的那么就返回
- Broadcast ： 逐步调用每个provider,如果有一台报错,在循环调用结束后,抛出异常

### 说说Dubbo的分层？

- service层: 服务层:主要是接口的定义以及实现
- config层:Dubbo配置层,用来实现一些dubbo的配置工作,比如通过注解或者xml等
- proxy层:负责生成消费者和提供者的代理对象,用来做一些扩展点,比如过滤器等
- registry:注册中心层:负责服务的一个注册
- cluster:集群层,可以用来做负载均衡,路由等功能
- protocol:协议层,服务之间通信对传输内容所遵循的协议
- exchange:信息交换层,用来封装请求响应模式,同步转异步
- serialize:序列化层,传输数据的序列化与反序列化过程
- monitor:监控层,监控服务之间的调用

### 服务提供者能实现失效踢出是什么原理？

- 服务失效踢出基于Zookeeper临时节点原理,客户端断开连接后,临时节点就会被删除,Zk中的节点是有生命周期的,具体的生命周期取决于节点的类型，节点主要分为持久节点和临时节点。

### 为什么要通过代理对象通信？

- 将调用细节封装起来,是的调用远程方法就像调用本地方法一样简单,还可以做一些其他方面的增强,比如负载均衡，容错机制，过滤操作，调用数据的统计

### 如何设计一个RPC框架？

- 首先需要一个注册中心,管理消费者和提供者的节点信息,这样才会有消费者和提供者去订阅服务,注册服务
- 多个提供者 需要做负载均衡
- 集群容错,一个提供者调用失败了怎么办
- 通信协议 采用什么类型的网络传输 以及什么方式序列化

### Dubbo服务之间的调用是阻塞的吗?

- 默认是同步等待结果阻塞的，支持异步调用. future-get
