### Java数据类型有哪些？

- 基本数据类型: short,int,long,float,double,byte,char,boolean 8个基本类型
- 引用数据类型: Integer,Long,Double,String,Character,Boolean... 以及自己创建的class
- boolean,byte 1字节,short,char 2字节,4,8

### String为什么是final的？

- 因为字符串存在于字符串常量池中,而字符串常量池都是在jvm的堆上,是线程共享的区域,如果多线程之间要是对同一个String对象进行了修改,那么就会导致线程不安全
- 还有标为final,避免子类去继承String,对String的方法进行重写,也是为了避免风险

### 抽象类和接口的区别？

- 都不能被实例化,接口的实现类和抽象类的 都只有实现了接口或抽象类中的方法才能被实例化。
- 1.8之前接口只有定义,后来加了默认方法,抽象类可以定义方法以及实现
- 接口implements,继承抽象类的关键字为extends,一个类可以实现多个接口,但一个类只能继承一个抽象类,接口之间可以多继承
- 接口的成员变量必须赋默认值, public static final的。

### Object中有哪些方法？

- equals()
- hashCode()
- toString();
- wait
- notify/notifyAll
- getClass
- clone

### 为什么重写equals()要重写hashCode？

- 首先equals默认是==,比较对象的地址,hashCode是根据地址hash出来的一个值,所以地址相同的对象,hashCode一定相同。
- java文档中说明了重写equals一定要重写hashCode,否则的话可能在 hashMap等集合中无法正常工作,因为我们知道map插入一个元素的时候,会首先判断当元素hash值相同并且equals相同,然后将元素进行替换,
  如果equals重写后,用equals相比两个对象是相同的,但是hashCode没重写,不相同,则map中可能包含了两个相同的key了。

### Java中的反射是什么？原理？

- **反射是在java程序运行时,对任何一个类都能够知道其所有的属性和方法,对任何一个对象都能够调用它的任何一个属性和方法。**
- java在编译完java文件后会生成class文件,反射可以通过class文件寻找对应的方法和属性。
- 获取class对象的方法有几种:
  - 可以通过**类.class**获取到class对象
  - 也可以通过**对象.getClass**获取到class对象
  - 也可以通过**Class.forName("全限定类名")**获取到class对象
- 之后可以根据class对象获取相应的方法、参数以及构造方法等

### Java中的反射的开销有哪些？

- 反射调用的参数使用的是变长数组,而且都是Object类型的
- 如果参数是基本类型,就会带来响应的装箱和拆箱
- 还有方法内联:method.invoke底层调用是通过委托模式来实现的,一个是本地实现(java->c++->java)
  还有一个是动态生成字节码,如果调用次数少于15次,那么就使用本地方法实现,如果超过15次就使用动态生成字节码的方式。(为了消除调用成本)

### JDK1.8新特性？

- Lambda表达式,是一个函数表达式,可以把lambda表达式认为是一个可以传递的代码,可以让代码变的更加整洁
- StreamAPI-流式API 集合、数组 （将处理的元素看做一种流,然后在管道里进行一系列操作,比如筛选,排序,聚合等处理
- HashMap 扩容时的策略变更 (之前要rehash、现在根据hashCode与数组长度n-1进行与运算)
- JVM元空间代替永久代,元空间存储在非堆上
- 新的时间日期API
- 接口中增加了默认方法

### CompletableFuture 有什么特性？

- 通过runAsync创建一个异步无返回值的线程,底层使用forkJoinPool线程池
- 通过supplyAsync创建一个带有返回值的线程,返回类型为CompletableFuture
- 通过Completable.join()等待方法的结束,但是不需要再使用try{}catch语句块.
- 可以对任务进行流水线操作
    - 合并两个线程的结果然后进行操作可以用 thenCombine
    - thenAccept消费处理结果
    - handle类似于thenAccept,但是多了异常的处理
    - 一个线程依赖另一个线程的时候,可以把这两个线程串行化
    - .exceptionally(lambda),可处理异常

### 如何查看线程信息？

- top命令可以查看进程pid ps -T -p <pid>   top -H -p <pid>
- 通过arthas,thread的命令,可以查看线程信息
- arthas都可以做什么？
  - 查看线程信息
  - dump堆信息
  - 查看jvm信息
  - 查看类加载器
  - 动态的替换类的class文件:
    - 首先通过jad将需要更改的文件进行反编译,保存下来
    - 然后在查看需要修改的类是通过哪个类加载器加载
    - 将修改完的文件在通过这个类加载器加载到JVM中

### Java线程的实现方式？

- 用户线程:完全建立在用户空间的线程上,线程的状态以及调度都在用户态中完成
- 内核线程(轻量级进程):线程的状态以及调度都由操作系统来负责。
- (用户线程+轻量级进程)混合:用户线程存在用户空间,然后操作系统提供轻量级进程,这样用户线程可以使用内核提供的线程调度的功能
- JDK1.2之后,Java采用了内核线程。

### Java线程状态？

- 线程是进程的子任务,是CPU调度的基本单位
- 新建状态:线程刚刚被创建
- 运行状态:包含了运行中的线程和等在CPU调度的线程
- 超时等待的线程:到一定时间会自动唤醒,不会等待 wait(time) sleep(time)
- 无限期等待的线程:不会自动唤醒,需要别人来唤醒 wait
- 阻塞状态:当前线程遇到了锁,被阻塞住 sync
- 结束状态:

### 操作系统进程状态？

- 进程系统进行资源调度和分配的基本单位
- 新建状态
- 就绪状态:等待CPU的一个调度。例如:时间片用完 | 进行由于IO操作完成而进入就绪态
- 运行状态:正在运行的进程
- 阻塞状态:由于等待IO 或者请求IO导致的阻塞
- 结束状态

### HashMap的存取原理讲解一下？

- 首先是计算key的hashCode,然后无符号右移16位,为了使hashCode更加的分散,避免哈希冲突。
- 然后通过计算之后的hashCode与数组长度减1进行&运算,因为数组长度是2的n次幂,所以位运算就相当于hashCode与数组长度取模,然后得到该key在数组的下标
- 然后判断该下标处是否有值,没有值的话就插入一个链表节点
- 有值的话就判断其属于链表节点还是Tree节点,遍历链表和树节点如果存在当前元素,就进行值的更新,否则就相应的插入到对应的节点当中,如果是链表节点的8,如果节点个数到8,就转为Tree节点
- 然后再判断元素个数是否超过集合的阈值,如果超过那么就进行扩容的操作。

### HashMap的扩容？

- hashMap的扩容是通过,hash值与数组长度进行计算得到结果,**因为我们计算数组下标的方式是通过哈希值与数组长度-1进行与运算,然后数组扩大了两倍,相当于高位增加了1位**,这样的话hashCode与
  多出来的那一位进行计算,如果是0就维持元素下标位置不变,如果是1,元素的下标扩大一呗。这样就完成了扩容.

### ConcurrentHashMap？

- 校验key和value不能为空
- 同样是计算key的hashCode,然后找到其对应的数组下标,如果为空,就通过cas(下标与一个内存地址的一个位运算)将该元素添加到集合中
- 然后判断当前元素是否正处于扩容阶段,如果处于扩容阶段,那么就进行协助扩容
- 否则锁定头节点,然后判断当前节点属于链表节点还是树节点,进行相应的插入操作,如果存在当前key,就将val值替换,并返回之前的值。

### ConcurrentHashMap如何扩容？

- ConcurrentHashMap的扩容实际上是将集合中的桶,分配给不同的线程,一个线程最少分到16个,避免过度竞争,每个线程处理不同区间的元素
- 扩容时遇到空的桶或者已经扩容完的桶,标记为ForwardingNode节点,然后跳过
- 单个桶内的扩容是加锁的,也是分为高位和低位元素,下标位置为高位i+n,低位i
- 全部迁移完之后,将当前table变为新的迁移之后的table

### ConcurrentHashMap如何计数？

- ConcurrentHashMap引入了两个变量,一个是baseCount,一个是CounterCell
  - baseCount负责简单计数,直接进行Cas操作,用于在没有竞争的情况下统计。操作失败再用CounterCell进行统计
  - CounterCell:
    - 这是一个数组，里面放着CounterCell对象，这个类里面就一个属性，其使用方法是，在高并发的时候，多个线程都要进行计数，
    - 每个线程有一个探针hash值，通过这个hash值定位到数组桶的位置.
    - 如果这个位置有值就通过CAS修改CounterCell的value（如果修改失败，就换一个再试）,如果没有，就创建一个CounterCell对象。
  - 最终将 基础值+数组中各个位置的值

### 什么是线程安全？

- 由于对象存在堆中,不同线程可能会访问到同一个对象,如果一个线程在操作某个对象的时候,其他线程修改了这个对象的,那么就可能造成线程安全的问题。

### 聊聊volatile？

- volatile是java中的一个关键字,其实现了多个线程读取一个共享变量的时候,能够读取到最新值,并且其也能够避免指令重排序
- 现在的CPU都是有缓存的,首先从主内存中将数据读到CPU缓存中,然后在到内存中去执行。volatile强制每次写数据的时候,都刷新到主内存,也会使得别的CPU缓存的 当前地址的数据无效。
- **将当前处理器缓存行的数据会写回到系统内存,这个写回内存的操作会引起在其他CPU里缓存了该内存地址的数据无效。**

### CAS了解么？

- CAS字面意思就是比较并交换,CAS需要三个元素:
    - 要修改对象的地址
    - 要修改对象的原值
    - 要修改的值
- 如果传入的修改对象的原值和实际对象地址的值相同,那么就将此地址上的值替换成新的值
- CAS缺点,ABA问题,如果在修改过程中,有其他一个线程将该对象修改之后又修改回来,CAS还是会操作成功
- AtomicStampReference 能够解决这个问题,使用的版本号机制,每次修改后版本号都进行变更

### 聊聊Synchronized?

- synchronized 是JAVA中的同步锁,1.6之前是一把重量锁,1.6之后进行了一些优化,使其有了偏向锁、轻量级锁、重量级锁这三种概念
- 我们知道对象头中包含了hashCode、线程ID、GC年龄、偏向锁标记、锁标识等。
- 偏向锁: 某个线程去获取锁的时候,将自己的线程ID通过CAS设置在锁对象头上,如果设置成功,那么代表获得了偏向锁,如果后续该线程继续获取锁的话,那么直接比较线程ID是否相同即可。
- 轻量级锁:某个线程去获取锁的时候,将锁对象的MarkWord复制到本线程的锁记录上,然后将锁对象中的MarkWork中的锁记录指针通过CAS指向当前线程的锁记录,如果设置成功,那么代表获取到了轻量级锁,如果没有获取到,
  那么进行一定次数的自旋,如果仍然获取不到,那么就升级为重量锁。
- 重量级锁:调用操作系统底层的互斥锁,然后呢每个对象都有一个monitor监视器,存在同步队列,和等待队列,同步队列就是多个竞争锁的线程,等待队列就是调用Object.wait()后,进入的队列,不会去抢占锁。

-使用场景:

- 偏向锁的目标是,减少无竞争且只有一个线程使用锁的情况下，使用轻量级锁而产生的性能消耗. HashTable,一个线程中重复的去获取锁。
- 轻量级锁的目标是,而是在没有多线程竞争的情况下,减少无实际竞争情况下,使用重量级锁产生的性能消耗,包括系统调用引起的内核态与用户态切换、线程阻塞造成的线程切换等
- 追求吞吐量。同步块执行速度较长。

### 聊聊ReentrantLock?

- ReentrantLock是JDK并发包下提供的一个锁工具类,支持公平锁和非公锁,也是依靠AQS来实现的。
- 线程在获取锁的时候,通过cas将锁状态state从0变为1,如果cas成功,并设置当前线程ID,代表获得锁成功。
- 如果cas失败,在进行一次获取锁并判断当前线程是否为独占锁,如果是那就进行锁的重入将sate进行+1,否则就将当前线程加入到等待队列并进行阻塞。

### Condition是什么?

- Condition 实现了管程模型里面的条件变量。类似于Object中的wait,notify,notifyAll。用于在并发环境下,协调某一时刻哪个线程去能够执行,哪个线程阻塞等。
- 提供了await().single().等方法

### Synchronized和ReentrantLock的区别？

- 一个是JDK内置的一个关键字,一个是JAVA并发包下写的并发锁
- Synchronized是非公平的,ReentrantLock支持公平和非公平两种模式
- Synchronized会一直阻塞到获取到锁,ReentrantLock支持尝试获取锁,以及指定超时时间
- ReentrantLock支持多个条件队列,并对不同的条件队列的线程进行协调调度。
- 在线程竞争激烈的情况下Synchronized的性能要比ReentrantLock的性能低,Synchronized使用的是CPU的悲观锁,每次都要去竞争锁,而ReentrantLock底层使用的是CAS去获取锁,本质上是一个乐观锁。
- synchronized异常会主动释放锁,lock不会

### ReentrantReadWriteLock 原理?

- 读写锁:读读共享、读写互斥、写写互斥
- 读写锁是通过锁状态的高低位来区分读写锁的数量的。高16位是读锁,低16位是写锁。
- 内部结构存储了两个对象,一个是读锁,一个写锁。同样是调用AQS获取共享锁和获取独占锁以及释放共享锁及释放独占锁。然后呢自己实现尝试获取锁和尝试释放锁的逻辑部分。
- 读锁加锁的时候,首先判断当前是否有写锁,如果有写锁,并判断是否为当前线程,不是当前线程就返回,如果没锁,那么就加读锁,判断读锁数量,如果超过最大值,就返回,
  没超过判断是否为第一个读锁线程,如果是就计数++,如果不是就通过HolderCount在对应的线程计数器上进行+1
- 写锁加锁的时候,判断是否有读锁,如果有读锁,就返回,然后判断是否有写锁,如果没写锁,就进行加锁,如果有写锁,判断是不是当前线程,如果是就是锁重入,然后将锁计数进行+1

### StampedLock?

- 读写锁,但是支持读的时候存在一个写线程。

### AQS？

- AQS维护了一个状态变量state来维护同步状态
- 并且维护了一个双向链表,用于存储获取锁失败的线程
- 然后根据独占锁和共享锁分别实现了一套获取锁和释放锁方法,即入队和出队的过程。

<img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/java/javacore/concurrent/aqs_4.png" alt="AQS获取锁流程">

### CountDownLatch、CyclicBarrier、FutureTask知道吗？讲讲？

- CountDownLatch:
    - 也是依赖AQS,利用State做计数器的功能,初始化countDownLatch的时候,会对state的值进行初始化,当countDownLatch调用await的方法的时候,会判断state是否为0,如果为不为0的话
      就将当前线程挂起,进行阻塞。
    - 如果线程调用了countDownLatch的countDown方法,会将state进行减1操作,并唤醒阻塞队列中的线程,然后判断state是否为0,如果不为0的话接着挂起。
- CyclicBarrier:
    - 是多个线程相互等待,到达某一个临界点,然后结束获取去执行下一组任务。
    - CyclicBarrier内部有一个计数器,每个线程到达屏障点的时候会调用await方法将自己进行阻塞,然后计数器count进行减1,当计数器减为0的时候,所有因await方法而阻塞的线程将要被唤醒。
- FutureTask:
    - 内部维护了几个状态,一个是新建状态,一个是执行中状态,其他包括正常结束、异常、中断等状态，如果当前futureTask状态是新建和执行中的状态,那么就把当前线程挂起,等待所有线程执行完毕。




















