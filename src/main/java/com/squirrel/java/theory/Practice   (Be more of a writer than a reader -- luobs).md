**Practice**   (Be more of a writer than a reader -- luobs)

------

#### HashMap

1.  首先计算key的hashCode,然后进行右移16位，然后进行一个异或运算。避免hash值得低位冲突,造成hash碰撞的概率变高。
2.  然后判断数组是否为空以及数组的长度是否为0,如果为空或0,那么进行一次扩容操作。 如果指定了集合容量,就取与该容量最接近的2的n次幂的容量。保证集合的大小为偶数。
3. 用计算过后的hash值与数组长度减1进行位运算,当数组长度位2的n次幂的时候就相当于, hash值与数组长度进行取模运算,这样的话就能计算出当前key在数组中的下标。
4. 然后判断当前下标处时候有值,如果无,那么就直接将值插入到当前下标下。
5. 如果有值,判断第一个节点的key是否是要插入的key的值,如果是的话,那么将该key 的值进行替换。
6. 如果不相同,判断头结点是链表节点还是红黑树节点，如果是链表节点的话,就将遍历该链表,然后判断是否有该节点的key,如果有就替换值即可，如果没有就插入到链表尾部，
7. 然后判断链表的长度是否大于8,如果大于8那么就转换成红黑树。
8. 如果是红黑树就按照红黑树的方式插入到红黑树的节点上。
9. 然后判断容量是否达到了集合的阈值,如果超过了 那么进行扩容。

ConcurrentHashMap

1. 校验 key和value不能为空
2. 计算key 的hashCode,  然后 判断数组是否为空,如果为空,就去初始化数组,不过是保证了一个线程去初始化。使用cas通过sizeCtl变量来保证的。
3. 然后根据hashCode与数据组的长度确定到数组的下标,然后判断当前下标处是否有值, 无值得话,通过cas设置该节点。
4. 如果不为空判断是否处于迁移阶段, 如果是处于迁移阶段,那么去进行协助迁移
5. 否则使用synchronized锁定头结点,如果是链表就插入到链表尾部,如果是红黑树节点就按照红黑树的插入逻辑插入到红黑树中,链表长度到8就转为红黑树。

hashmap长度设置为2的原因？

1. hashmap计算hashCode的时候总是将 高16位和低16位进行异或运算的到最终的hash值,这样可以保留高位的特征,避免某些key 的低位相同,造成hash冲突。
2. 同时数组下标计算方式是, hashCode与n-1进行位运算，在2的n次幂情况下,类似于 hashCode%n，位运算更快一些

hashmap扩容后需要rehash吗？

1. 不需要,扩容情况下,数组扩大2倍,所以当hashCode与数组长度取模的时候,只需要多看1位,如果运算完是1,那么就将原位置的元素添加到原数组长度+当前下标的位置上,如果是0就保持原来元素的位置不变。

为什么在链表长度为8的时候进行转换？

1. 遵循泊松分布的概率,链表长度为8的概率很低很低
2. 当链表长度大于8的时候,红黑树的时间复杂度小于链表的时间复杂度。

hashmap与ConcurrentMap区别？

1. key 和 value  hashmap可以为空
2. hashmap是线程不安全的。  

LinkedHashMap？

1. 链表，结构就是hashmap 然后每个节点存有两个指针,指向前一个节点和后一个节点,形成一个双向链表。
2. accessOrder实现了按照顺序插入以及访问顺序。

ArrayList和LinkedList？

1. 底层是一个Object数组,默认数组长度为0,添加第一个元素的时候会初始化一个数组长度为10的数组,后面如果元素超过数组长度,那么进行扩容,新数组的容量为原来的1.5倍
2. LinkedList底层使用的是双向链表,每个节点保存了指向前驱节点和后继节点的指针,初始化时,不执行任何操作,添加第一个元素时候,再去构造链表中的节点。

##### Lock

1. CAS涉及三个操作数

   1. 读写内存的地址
   2. 读内存地址的原值
   3. 想替换的新值
   4. 当期望的值等于传入的值,那么进行交换。

2. CAS的缺点：

   1. ABA问题,如果一个线程在进行CAS操作的时候,如果另一个线程对其进行了修改然后又改回了原值,这个线程不能感知却还能继续对该地址的值进行操作。
   2. 自旋操作
   3. 只能对一个共享变量进行操作。  可以使用AtomicStamp 的类来避免这种问题，提供了一个版本号的概念。

3. Synchronized？

   1. Synchronized是一个同步锁,1.6之前是一个重量锁, 1.6之后进行了一系列优化,有几种锁的概念,偏向锁、轻量级所、重量级锁。每个对象的对象头中都包含了一个MarkWord,这个MarkWord中包含了  线程ID,hashCode ,GC年龄等
   2. 偏向锁：线程在获取锁对象的时候,将自身的线程ID通过CAS设置到锁对象上,如果设置成功,则证明获取偏向锁成功,然后该线程下次再获取锁的时候,只需要比较自身ID和锁对象中的线程ID是否相同,如果相同,则证明获取到了锁。
   3. 轻量级锁：线程将锁对象的MarkWord复制到自身的MarkWord上,然后在将markword通过CAS设置到锁对象上,如果设置成功,那么代表获取到轻量级锁。如果获取不到就通过一个自适应自旋的操作去获取锁,如果还获取不到那么久升级为重量级锁。
   4. 重量级锁：使用的是操作系统底层的互斥锁。每个对象都有一个monitor对象,并且存在几个队列。 
      1. 竞争队列:  存在多个竞争锁的线程   先进后出的一个队列。
      2. 等待队列：调用wait方法的会进入等待队列
      3. 候选队列：获取到锁的线程会从竞争对队列尾部选取一个线程加入候选队列,与末尾入队的线程进行竞争锁

4. 谈谈ReentrantLock？

   1. 基于AQS 抽象队列同步器, AQS提供了一个state 代表锁的状态, 0 代表无锁
   2. ReentrantLock 首先对state 尝试用cas 将其从0变为1,如果成功,并设置当前线程ID,则证明获取锁成功
   3. 如果cas失败,在进行一次获取锁，然后如果失败后再判断其是否是锁重入，如果是重入将 state+1,获取锁成功
   4. 如果再次获取锁失败  那么加入等待队列。

5. **Synchronzied 和 ReentrantLock区别？**

   1. Synchronized不支持响应中断, ReentrntLock支持响应中断
   2. reentrant支持超时放弃竞争锁,synchronized会一直阻塞到获取到锁
   3. 线程激烈的情况下 reentrantlock 性能会更好一些。
   4. synchronized是非公平锁,reen支持两种模式

6. **谈谈你对AQS的理解？**

   1. AQS是一个抽象队列同步器,帮助你实现了线程获取不到锁的时候入队和出队的功能,只需要我们实现一个锁的时候,重写获取锁的部分以及释放锁的部分即可。 tryAcquire 和 tryRelease等方法。

7. **读写锁以及底层实现**？

   1. 读写锁的一个原理其实就是。  读写互斥、写写互斥、读读不互斥。 
   2. 读写锁呢,根据一个整形变量的字段 高16位和低16位来区分是读锁还是写锁，低16位是写锁,高16位是读锁。
   3. 写锁的读取与释放：如果state为0,证明读锁为0,
   4. 读锁的读取与释放：

8. **线程池设置**？

9. **并发工具**？

10. #### Redis

    - Redis**有哪些结构**？
    - Redis过期key是如何清理的？
    - **Zset是怎么执行查询操作的？**
    - **Redis为什么是单线程的以及为什么这么快？**https://www.jianshu.com/p/bc6904abc330
    - Linux IO模型有哪些？
    - 聊聊IO多路复用模型？
    - Redis缓存穿透？
    - Redis缓存击穿？
    - **Redis缓存雪崩?**
    - Redis缓存与数据库一致性问题如何解决？
    - Redis持久化如何实现的？
    - AOF和RDB的区别？
    - AOF如何防止文件越来越大？
    - AOF持久化方式？
    - 跳跃表与平衡树,哈希表的比较？
    - 为什么Mysql不是用跳跃表作为索引？
    - **为什么平衡二叉树也不适合作为索引？**https://www.cnblogs.com/aspirant/p/9214485.html
    - 红黑树

11. Mysql

