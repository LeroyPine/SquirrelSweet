### 1.HashMap put 过程？

- hashMap 是由数组+链表+红黑树构成的.
- 首先计算key的hashCode,
- 如果数组为空null或者数组的大小为0,那么就进行扩容操作(此时扩容操作,如果指定了初始化容量大小,那么就为指定的容量大小, 否则就使用默认的hashMap的容量大小)
- 用key的hashCode与数组长度进行取余,算出key应该在数组中的位置,如果当前位置没有值,那么直接初始化一个Node 节点,放置在该位置。
- 如果该位置有数据,比较第一个元素是否和我们插入的元素是否相同,如果相同,那么就进行将该值取出来,如果存在旧的key 和新的key相同,那么就直接返回旧值.
- 如果该值有数据第一个元素且不是我们要插入的元素,那么就判断这个元素是属于树节点还是链表节点,如果是红黑树节点, 就调用红黑树的插入方法,如果是链表的话就调用链表的插入方法。链表特殊的一点就是插入到链表尾部,如果链表的元素到了8个
  ,那么就将链表转为红黑树。
- 最后判断当前map的元素是否大于设定的阈值,如果超过了那么就进行扩容.

### 2.HashMap resize的过程？

- 将数组的大小扩容一倍,如果旧的数组大小大于等于默认的阈值,那么新的阈值也扩容一倍,否则阈值还是新的数组大小乘以 负载因子,然后进行元素的迁移,如果数组位置上只有单个元素,那么直接计算新的下标值,
  hashCode与数组长度-1取余得到下标 放入新的数组中,如果数组位置上不是一个元素,那么判断该节点属于链表还是树节点,如果是链表节点就拆分为两个链表
  用hashCode与数组长度进行取余,为0的被称为低位链表,为1的被称为高位链表,低位链表下标位置和其在原数组的下标位置保持相同 ,高位链表的下标放置在原下标 + 数组长度的新的下标处。

### 3.HashMap 位运算如何保证索引不出界？

- hashMap 保证了数组的长度为2的n次幂,在计算下标的时候 n-1 & hashCode 相当于 hashCode % n 从而保证了下标小于 数组的长度,从而不会越界。

### 4.HashMap 线程不安全 ？

JDK8

- 两个线程同时PUT时候,判断链表的下一个节点如果为空就 将节点的next,添加一个新的节点, 两个线程同时操作时可能将其中一个线程设置的节点 替换,会造成数据丢失。
- put和get并发时,可能导致get为null,当数组扩容的时候,此时 数组将被替换成一个新的数组,数据未迁移时候新数组为空,从而get到的数据为null
- JDK7
- 多线程在扩容的情况下，由于链表采用的是头插法,当迁移的时候，线程1创建一个空数组暂停,线程2 直接执行完毕，并将链表的顺序翻转,从而产生循环链表， 举例：线程1进行到扩容那一步,让出CPU
  线程而顺利执行完毕，此时链表已经反转，线程1拿到的是翻转之后的，然后再进行头插法,由于线程1已经改变了链表的指向，从而 线程1操作后形成了循环链表。

### 5.ConcurrentHashMap

- ConcurrentHashMap { 1.8：synchronized + CAS + HashEntry + 红黑树 1.7：ReentrantLock + Segment + HashEntry }

- 1.7 将数据分为一段一段的存储,然后给每一段数据配一把锁，当一个线程占用锁访问其中一段数据时。
- 1.8 选择了与HashMap相同的Node数组+链表+红黑树的结构。抛弃了原有的Segment锁 采用 CAS+Synchronized实现更细粒度的锁。

- 为什么用内置锁替换可重入锁？
    - synchronized 有了大量的优化 无锁-偏向锁-轻量级锁-重量级锁。
    - 减少内存开销,每个节点都需要通过AQS获得同步支持，其实并不是每个节点都需要同步支持的。链表头结点或者红黑树头结点需要同步。

- 1.8：将锁的级别控制在了更细粒度的哈希桶组元素级别,也就是说只要锁住这个链表头结点（红黑树的根节点）,就不会影响其他的 哈希桶数组元素的 读写，大大提高了并发度。

- put:
    - 1.根据key计算出hash值,判断是否要进行初始化，定位到Node,拿到首节点f,判断首节点f。
    - 2.如果为NULL 就通过CAS的方式尝试添加, 如果 f.hash= MOVE = -1,说明其他线程在扩容，参与一起扩容。
    - 3.如果都不满足，锁住首节点，判断是链表还是红黑树进行遍历插入。
    - 4.当链表长度达到8的时候,数组扩容或者将链表转换为红黑树。

- get:
  1.计算key的hash值,确定key所存在的数组下标处,如果是首节点返回，如果不是 那么就判断红黑树还是链表,如果是红黑树则红黑树查询，链表则在链表返回

- 协助扩容：
    - 根据操作系统的CPU核数和集合length计算每个核一轮处理桶的个数
    - 修改迁移节点的下标，一个线程领取完任务后, 第二个线程要在第 数组长度-第一个线程处理的节点个数的位置进行处理，以此类推
    - 领取完要处理的节点后进行处理,进行同步处理
    - 直到最后一个线程处理完。 旧的数组被新数组替换掉

  // 简要总结：

    - 分配任务： 把一个大数组切分，切分成多个小份，然后每个线程处理其中每一小份，当然可能只有一个或几个线程在扩容，那就一轮轮的处理，直到 处理结束。
    - 复制部分主要有两点，第一点加锁，第二点处理完之后置为ForwardingNode标记这个位置被迁移过。
  

  



